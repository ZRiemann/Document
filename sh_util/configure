#!/bin/sh

#===============================================================================
# MIT License
# Copyright (C) 2018 Z.Riemann
#
#-------------------------------------------------------------------------------
# auto configure source code tree rule:
#
#-------------------------------------------------------------------------------
# options
function print_usage(){
cat << !USAGE_END!
Options:
  -h, --help                       print the usage message
  --license                        print the MIT License
Auto make rules:
  --show-path-rule                 <reserved> print sample auto make tree rule
  --show-code-rule                 print embedded codes rule
  --with-code-rule                 auto generate Makefile by auto-code-rule
  --with-path-rule
Adapter no rules:
  --libs-path=[path1:path2:...]    <reserved>
                                   librarys path
                                   auto build path name: lib<name>
                                   auto exclude path: test[s]
  --excl-libs-path=[libpath/exclpath:] <reserved>
                                   exclude path in librarys path
Outputs:
  ./bin                            binary files directory
    |- obj_debug                   debug version objects
    |- debug                       debug version libs or apps
    |- obj_release                 release version objects
    |- release                     release version libs or apps
    |- obj_arm ...                 base arm linux
    ...
  execute programs as follow:
  $ bin/release/<app-name> [--options]
!USAGE_END!
}
# print_usage

# auto configure source code tree rule
function print_path_rule(){
cat << !CFG_RULE_END!
1. library top path: lib<lib-name>
2. application top path: app<app-name>
!CFG_RULE_END!
}
# print_path_rule

# auto configure embedded scripts code rule
function print_code_rule(){
cat << !CODE_RULE_END!
1. library codes
   output: lib<name1>.so<.1.0.0> lib<name2>.so<.1.0.0>
   /**
    * @zmake.lib <lib-name1>:<lib-name2>:...
    * @zmake.ignote
    */

    @zmake.lib    ; module of lib-name*
    @zmake.ignore ; do not compile this file

2. application codes
   output: <app-name1> <app-name2> ...
   /**
    * @zmake.app.module <app-name1>:<app-name2>:...
    * @zmake.app.main <app-name>
    * @zmake.app.dependent <lib1>:<lib2>
    */

    @zmake.app.module    ; module of app-name*
    @zmake.app.main      ; app-name main entry file
    @zmake.app.dependent ; list dependentlibrarys,
                         ; followed by @zmake.app.main
!CODE_RULE_END!
}
# print_code_rule

# pint the configure file license
function print_license(){
cat << !LICENSE_END!
MIT License

Copyright (c) 2018 Z.Riemann

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
!LICENSE_END!
}
# print_license

# linux shell color control
# cl_: color_
# r: red; g: green; y: yellow; p: purple
# c: close color control
# echo -e "${cl_r}echo red color${cl_off}"
cl_r="\\033[31m"
cl_g="\\033[32m"
cl_y="\\033[33m"
cl_b="\\033[34m"
cl_p="\\033[35m"
cl_c="\\033[0m"

# options
# 0-code-rule; 1-path-rule 3-no-rule
rule_code="rule-code"
rule_path="rule-path"
rule_null="rule-null"
rule_mode=$rule_code

# get_options

#===============================================================================
# Generate Makefile

# backup the exist dir or files, <name> => <name>.backup
function backup(){
    echo -e "${cl_b}Start backup $*${cl_c}"
    echo -e "${cl_r}backup files task delay...${cl_c}"
}
# backup Makefile makefile bin

# just remove Makefile makefile bin
echo -e "${cl_y}WARNNING: Makefile makefile bin will be deleted...${cl_c}"
rm -fr Makefile makefile makefile_obj makefile_all src/auto_version.h bin

# prepare environment before configure
if [ -f build/preconfigure ]; then
    echo "${cl_b}Prepare environment before configure${cl_c}"
    . build/preconfigure
fi

# preconfigure
CC=gcc
CFLAG=-I.

# scan source codes
target_count=0
dependent_file=""
obj=""
obj_dir="bin/obj_debug"
# [lib|app] : <objs> <depedents>
makefile_obj="makefile_obj"
# all : <libs> <apps>
makefile_all="makefile_all"
# is lib or app
is_lib=0
# zmake tag prefix
zmake="@zmake."
# zmake tag list
zmake_tag=""
# zmake type: cc/lib/app
zmake_type=""
# zmake value;
zmake_value=""
# current cc
zmake_cc=$CC
zmake_cflag=$CFLAG
# buffered all targets
zmake_target=""

printf "all :" >> $makefile_all

function parse_zmake_target(){
    # parse target1:target2:...
    # append target to all
    while :; do
        zmake_tgt=${zmake_value%%:*}
        zmake_value=${zmake_value#*:}

        [[ "$zmake_target" =~ "$zmake_tgt" ]] || {
            target_count=$((target_count + 1))
            # append obj to all, limit 5 objs per line
            if [ 0 -eq $(($target_count % 5)) ]; then
                zmake_target+=" $zmake_tgt \\"
            else
                zmake_target+=" $zmake_tgt"
            fi
        }

        # target
        obj=$obj_dir/${path_name%.*}.o

        echo -e "${target_count}\t${path_name}\t${obj}\t${file_name}\t${obj_path}"
        echo >> $makefile_obj
        echo "$obj : ${path_name}$dependent_file" >> $makefile_obj
        printf "\t${zmake_cc} ${zmake_cflag} -c -o $obj $path_name\n" >> $makefile_obj

        [ "$zmake_tgt" = "$zmake_value" ] && break
    done
}

function parse_zmake_type(){
    # all : targets
    while :; do
        zmake_tag=${zmake_tag#*.}
        zmake_type=${zmake_tag%% *}

        [ "$zmake_tag" = "$zmake_type" ] && break

        zmake_tag=${zmake_tag#* }
        zmake_value=${zmake_tag%%;*}
        echo "${zmake_type} : ${zmake_value}"

        case "$zmake_type" in
            cc) zmake_cc=${zmake_value};;
            lib) parse_zmake_target;;
            app) parse_zmake_target;;
            *) echo -e "${cl_r}UNRECOGNIZED TYPE: ${zmake_type}${cl_c}";;
        esac
    done

    # reset cc, maybe replaced by @zamke.cc g++
    zmake_cc=CC
}

if [ "$rule_mode" = "$rule_code" ]; then
    for path_name in $(find . -type f -a \( -name \*.c -o -name \*.C -o \
                            -name \*.cc -o -name \*.cpp -o -name \*.CPP \
                            -o -name \*.c++ -o -name \*.cp -o -name \*.cxx \)); do
        # remove ./ prefix
        path_name=${path_name#*./}
        # parse file name
        file_name=${path_name##*/}
        # make obj dir
        obj_path=$obj_dir/${path_name%/*}
        mkdir -p ${obj_path}

        # parse code rule ...
        zmake_tag=$(grep $zmake $path_name)

        if [ -n "$zmake_tag" ]; then
            parse_zmake_type
        else
            echo -e "${cl_y}not find flag<$zmake> in $path_name${cl_c}"
            continue
        fi
    done
fi

# merge makefile_all and makefile_obj to Makefile
cat << !AUTO_VER! > src/auto_version.h
#define VER_AUTO 1
const int major_version=1;
const int minor_version=0;
const int revision_version=0;
const char *version= "1.0.0";
const char *build_date = "2018-03-21";
const char *git_rev = "git-ver-temp";
!AUTO_VER!

mv $makefile_all Makefile
echo >> Makefile
cat $makefile_obj >> Makefile
rm -f makefile_*
