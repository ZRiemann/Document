#!/bin/sh

#===============================================================================
# MIT License
# Copyright (C) 2018 Z.Riemann
#
#-------------------------------------------------------------------------------
# auto configure source code tree rule:
#
#-------------------------------------------------------------------------------
# options
function print_usage(){
cat << !USAGE_END!
Options:
  -h, --help                       print the usage message
  --license                        print the MIT License
Auto make rules:
  --show-path-rule                 <reserved> print sample auto make tree rule
  --show-code-rule                 print embedded codes rule
  --with-code-rule                 auto generate Makefile by auto-code-rule
  --with-path-rule
Adapter no rules:
  --libs-path=[path1:path2:...]    <reserved>
                                   librarys path
                                   auto build path name: lib<name>
                                   auto exclude path: test[s]
  --excl-libs-path=[libpath/exclpath:] <reserved>
                                   exclude path in librarys path
Outputs:
  ./bin                            binary files directory
    |- obj_debug                   debug version objects
    |- debug                       debug version libs or apps
    |- obj_release                 release version objects
    |- release                     release version libs or apps
    |- obj_arm ...                 base arm linux
    ...
  execute programs as follow:
  $ bin/release/<app-name> [--options]
!USAGE_END!
}
# print_usage

# auto configure source code tree rule
function print_path_rule(){
cat << !CFG_RULE_END!
1. library top path: lib<lib-name>
2. application top path: app<app-name>
!CFG_RULE_END!
}
# print_path_rule

# auto configure embedded scripts code rule
function print_code_rule(){
cat << !CODE_RULE_END!
1. library codes
   output: lib<name1>.so<.1.0.0> lib<name2>.so<.1.0.0>
   /**
    * @zmake.lib <lib-name1>:<lib-name2>:...
    * @zmake.ignote
    */

    @zmake.lib    ; module of lib-name*
    @zmake.ignore ; do not compile this file

2. application codes
   output: <app-name1> <app-name2> ...
   /**
    * @zmake.app.module <app-name1>:<app-name2>:...
    * @zmake.app.main <app-name>
    * @zmake.app.dependent <lib1>:<lib2>
    */

    @zmake.app.module    ; module of app-name*
    @zmake.app.main      ; app-name main entry file
    @zmake.app.dependent ; list dependentlibrarys,
                         ; followed by @zmake.app.main
!CODE_RULE_END!
}
# print_code_rule

# pint the configure file license
function print_license(){
cat << !LICENSE_END!
MIT License

Copyright (c) 2018 Z.Riemann
https://github.com/ZRiemann/zmake.git

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
!LICENSE_END!
}
# print_license

# linux shell color control
# cl_: color_
# r: red; g: green; y: yellow; p: purple
# c: close color control
# echo -e "${cl_r}echo red color${cl_off}"
cl_r="\\033[31m"
cl_g="\\033[32m"
cl_y="\\033[33m"
cl_b="\\033[34m"
cl_p="\\033[35m"
cl_c="\\033[0m"

# options
# 0-code-rule; 1-path-rule 3-no-rule
rule_code="rule-code"
rule_path="rule-path"
rule_null="rule-null"
rule_mode=$rule_code

# get_options

#===============================================================================
# Generate Makefile

# backup the exist dir or files, <name> => <name>.backup
function backup(){
    echo -e "${cl_b}Start backup $*${cl_c}"
    echo -e "${cl_r}backup files task delay...${cl_c}"
}
# backup Makefile makefile bin

# just remove Makefile makefile bin
echo -e "${cl_y}WARNNING: Makefile makefile bin will be deleted...${cl_c}"
rm -fr Makefile makefile makefile_* makefile_all src/auto_version.h bin

# prepare environment before configure
if [ -f build/preconfigure ]; then
    echo "${cl_b}Prepare environment before configure${cl_c}"
    . build/preconfigure
fi

# preconfigure
CC=gcc
CFLAG=-I.
LIB_SONAME=1.0.0
BUILDS=release
BIN_ROOT=bin


# scan source codes
#target_count=0
dependent_file=""
obj_name=""
obj_dir="bin/obj_debug"
# [lib|app] : <objs> <depedents>
makefile_obj="makefile_obj"
# all : <libs> <apps>
makefile_all="makefile_all"
# is lib or app
is_lib=0
# zmake tag prefix
zmake="@zmake."
# zmake tag list
zmake_tag=""
# zmake type: cc/lib/app
zmake_type=""
# zmake value;
zmake_value=""
# current cc
zmake_cc=$CC
zmake_cflag=$CFLAG
# buffered all targets
zmake_target=""
# obj sub directorys
zmake_subdir=""
# install directorys
zmake_install_bin="/usr/local/bin"
zmake_install_lib="/usr/local/lib"
zmake_install_inc="/usr/local/include"

# version configure
# major.minor.revision
zversion="1.0.0"
zver_major=${zversion%%.*}
zver_minor=${zversion#*.}
zver_minor=${zver_minor%.*}
zver_revision=${zversion##*.}
echo "ver: ${zver_major}.${zver_minor}.${zver_revision}"
# base => alpha => beta => RC => relaease
zalbt="alpha"
# build date
zdate=$(date '+20%y%m%d')
echo $zdate
# git version
zgit_rev=$(which git)
if [ -z ${zgit_rev##*/git} ]; then
    zgit_rev=$(git rev-parse HEAD)
else
    zgit_rev="nil"
fi
echo $zgit_rev

# generate auto_version.h
cat << !AUTO_VER! > auto_version.h
#define VER_AUTO 1
const int major_version=${zver_major};
const int minor_version=${zver_minor};
const int revision_version=${zver_revision};
const char *version= "${zversion}.${zalbt}";
const char *build_date = "${zdate}";
const char *git_rev = "${zgit_rev}";
!AUTO_VER!

# generate micro definitions
cat << !MAKE_ALL! > $makefile_all
ifeq (\$(BUILDS), debug)
	OPTM=-g
else ifeq (\$(BUILDS), release)
	OPTM=-O3
else
	BUILDS=release
	OPTM=-O3
endif
!MAKE_ALL!

echo >> $makefile_all
echo "CC=${CC}" >> $makefile_all
echo "CFLAG=${CFLAG}" >> $makefile_all
echo "LIB_SONAME=${LIB_SONAME}" >> $makefile_all
echo "BIN_ROOT=${BIN_ROOT}" >> $makefile_all
echo "INST_BIN=${zmake_install_bin}" >> $makefile_all
echo "INST_LIB=${zmake_install_lib}" >> $makefile_all
echo "INST_INC=${zmake_install_inc}" >> $makefile_all
echo >> $makefile_all
printf "all : prepare " >> $makefile_all

# prepare header files
header_file=$(find . -type f -a \( -name \*.h -o -name \*.hpp \))
#for dep_match in ${header_file}; do
#    echo "match: $dep_match "
#done
#echo "header files: ${header_file}"

function parse_zmake_target(){
    # parse target1:target2:...
    # append target to all
    while :; do
        # zmake_tgt = target1
        zmake_tgt=${zmake_value%%:*}
        # zmake_value = target2:...
        zmake_value=${zmake_value#*:}

        zmake_tgt_name=${zmake_tgt}
        if [ "lib" = "$zmake_type" ]; then
            # zsi => libzsi.so
            zmake_tgt_name=lib${zmake_tgt}.so
        fi
        # test new target
        [[ "$zmake_target" =~ "$zmake_tgt_name" ]] || {
            #target_count=$((target_count + 1))
            zmake_target+=" $zmake_tgt_name"
        }

        # target : source.o
        [ -f "makefile_${zmake_tgt_name}" ] || {
            # tag app or lib, for what type to build
            echo "# ${zmake_type}" > makefile_${zmake_tgt_name}
            # target :
            printf "\$(BIN_ROOT)/\$(BUILDS)/${zmake_tgt_name} :" >> makefile_${zmake_tgt_name}
        }
        # target : ... obj.o
        printf " ${obj_name}" >> makefile_${zmake_tgt_name}
        # test end of item: zmake_tgt == zmake_value == last target
        [ "$zmake_tgt" = "$zmake_value" ] && break
    done
}

function parse_zmake_type(){
    # all : targets
    echo -e "${cl_p}parse $path_name ${cl_c}"
    while :; do
        zmake_tag=${zmake_tag#*.}
        zmake_type=${zmake_tag%% *}

        [ "$zmake_tag" = "$zmake_type" ] && break

        zmake_tag=${zmake_tag#* }
        zmake_value=${zmake_tag%%;*}
        echo "${zmake_type} : ${zmake_value}"

        case "$zmake_type" in
            cc)
                zmake_cc=${zmake_value};;
            lib | app)
                # source.o : source.c depedents.h
                obj_name="\$(BIN_ROOT)/obj_\$(BUILDS)/${path_name%.*}.o"

                # test new subdir
                obj_path=${obj_name%/*}
                [[ "$zmake_subdir" =~ "$obj_path" ]] || {
                    # append new sub ddir
                    zmake_subdir+=$obj_path
                }

                # find out dependents header files
                dependent_file=""
                for dep_header in $(grep "#include " $path_name); do
                    [ "#include" = "${dep_header}" ] && continue
                    # remove < , > or "
                    dep_header=${dep_header#*<}
                    dep_header=${dep_header%>*}
                    dep_header=${dep_header#*\"}
                    dep_header=${dep_header%\"*}
                    for dep_match in ${header_file}; do
                        [[ "${dep_match}" =~ "$dep_header" ]] && dependent_file+=" ${dep_match}"
                    done
                done

                echo >> $makefile_obj
                echo "$obj_name : ${path_name}$dependent_file" >> $makefile_obj
                if [ "app" = "zmake_type" ]; then
                    printf "\t\$(CC) \$(OPTM) \$(CFLAG) -c -o $obj_name $path_name\n" >> $makefile_obj
                else
                    printf "\t\$(CC) \$(OPTM) \$(CFLAG) -fPIC -c -o $obj_name $path_name\n" >> $makefile_obj
                fi
                # all : target ...
                # target : obj_name ...
                parse_zmake_target
                ;;
            *) echo -e "${cl_r}UNRECOGNIZED TYPE: ${zmake_type}${cl_c}";;
        esac
    done

    # reset cc, maybe replaced by @zamke.cc g++
    zmake_cc=$CC
}

if [ "$rule_mode" = "$rule_code" ]; then
    for path_name in $(find . -type f -a \( -name \*.c -o -name \*.C -o \
                            -name \*.cc -o -name \*.cpp -o -name \*.CPP \
                            -o -name \*.c++ -o -name \*.cp -o -name \*.cxx \)); do
        # remove ./ prefix
        path_name=${path_name#*./}

        # parse code rule ...
        zmake_tag=$(grep $zmake $path_name)

        if [ -n "$zmake_tag" ]; then
            parse_zmake_type
        else
            echo -e "${cl_y}not find zmake flag<$zmake> in $path_name${cl_c}"
            continue
        fi
    done
fi

# merge makefile_all makefile_<targets> and makefile_obj to Makefile
# makefile_all => Makefile
mv $makefile_all Makefile

# all : => all : target1 target2 ...
#echo $zmake_target >> Makefile
zmake_tgt_cpy=$zmake_target
while :; do
    # all : prepare <dir>/tgt ...
    [ -z "$zmake_tgt_cpy" ] && break
    # get last target <space>target1<space>target2 => target2
    zmake_tgt=${zmake_tgt_cpy##* }
    # remove last target <space>t1<space>t2 => <space>t1
    zmake_tgt_cpy=${zmake_tgt_cpy% *}
    # generate build rule
    printf " \$(BIN_ROOT)/\$(BUILDS)/$zmake_tgt" >> Makefile
done
echo >> Makefile

# prepare :
# @mkdir -p dirs...
echo >> Makefile
echo "prepare:" >> Makefile
printf "\t@mkdir -p \$(BIN_ROOT)/\$(BUILDS) \$(BIN_ROOT)/obj_\$(BUILDS) ${zmake_subdir}\n\n" >> Makefile

# target1 : obj1 obj2 ...
while :; do
    # test zmake_target is empty
    [ -z "$zmake_target" ] && break
    # get last target <space>target1<space>target2 => target2
    zmake_tgt=${zmake_target##* }
    # remove last target <space>t1<space>t2 => <space>t1
    zmake_target=${zmake_target% *}
    # generate build rule
    echo >> makefile_${zmake_tgt}
    if [ 1 -eq $(grep -c "# lib" makefile_${zmake_tgt}) ]; then
        # build library
        printf "\t\$(CC) \$(OPTM) -shared -Wl,-soname,${zmake_tgt}.\$(VER_MAJOR) -o \$@ \$^" >> makefile_${zmake_tgt}
        # install/uninstall
        echo >> makefile_${zmake_tgt}
        echo "install_${zmake_tgt} :" >> makefile_${zmake_tgt}
        printf "\t@echo install ${zmake_tgt}..." >> makefile_${zmake_tgt}
    else
        #build application
        #printf "\t@echo build application ${zmake_tgt}..." >> makefile_${zmake_tgt}
        printf "\t\$(CC) \$(OPTM) -o \$@ \$^ \$(${zmake_tgt}_DEP)" >> makefile_${zmake_tgt}
        # install/uninstall
        echo >> makefile_${zmake_tgt}
        echo "install_${zmake_tgt} :" >> makefile_${zmake_tgt}
        printf "\t@echo install ${zmake_tgt}..." >> makefile_${zmake_tgt}
    fi
    # append makefile_<target> to Makefile
    cat makefile_${zmake_tgt} >> Makefile
    echo >> Makefile
done

# obj1 : src1 src2 ... depedents ...
cat $makefile_obj >> Makefile

# generate make install/uninstall/clean
echo >> Makefile
echo "# install librarys and applications" >> Makefile
echo "install :" >> Makefile
printf "\t@echo install libs and apps\n" >> Makefile
echo >> Makefile
echo "# uninstall librarys and applications" >> Makefile
echo "uninstall :" >> Makefile
printf "\t@echo uninstall libs and apps\n" >> Makefile
echo >> Makefile
echo "# clean up" >> Makefile
echo "clean :" >> Makefile
printf "\t@rm -fr \$(BIN_ROOT) auto_version.h" >> Makefile


# remove temporary file
rm -f makefile_*
