* JNI
  https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html
** 1. Introduction
   JNI(JaveNativeInterface) allows JVM to interoperate with C/C++/assembly
*** 1.1 JNI OverView(原生接口概览)
   - Create, inspect, and update java objects(including arrays and strings).
   - Call Java methods
   - Catch and throw exceptions
   - Load classes and obtain class information
   - Perform runtime type checking
*** Historical Background(历史背景)
   JDK1.0/Netcape's JRI/MS-RNI
*** JNI Approach
** 2. Design OverView(设计概览)
*** 2.1 JNI Functions and Pointers(函数与指针)
      JNI Interface pointer 
      Pointer(pre-threadJNI/data structure) 
          \------> Pointer(an interface function)
                      \-> Pointer(an interface function)
                       ...
*JNI Interface Pointer* is only valid in current thread.
Native methods receive the JNI interface as an argument.
#+BEGIN_SRC c
extern "C" JNIEXPORT jstring JNICALL  Java_com_itc_erizo_MainActivity_stringFromJNI(
        JNIEnv *env, /* 同一线程的env相同，不同线程的env不同*/
        jobject /* this */) {
}
#+END_SRC

*** 2.2 Compiling, Loading and Linking Native Methods
    -D_REENTRANT/-D_POSIX_C_SOURCE
    System.loadLibrary("xxx");
    #+BEGIN_SRC java
    package pkg;
    class aaa{
            native double f(int i, String s);      // 
            static{
                    System.loadLibrary("pkg_aaa"); // library name
                    /* unix: libpkg_aaa.so
                     ,* windows: pkg_aaa.so
                     ,*/
                    /*
                     ,* RegisterNatives() function is particulary useful with
                     ,* statically linked functions.
                     ,*/
            }
    }
    #+END_SRC
*** 2.3 Resolve Native Method Names
#+BEGIN_SRC c
extern "C" JNIEXPORT jstring JNICALL  Java_com_itc_erizo_MainActivity_stringFromJNI(
        JNIEnv *env, /* 同一线程的env相同，不同线程的env不同*/
        jobject /* this */) {
}
#+END_SRC
- prefix: Java_
- 完整类名: com_itc_erizo_MainActivity_
- 函数名: stringFromJNI
- 重载方法: __<参数名缩写>

Table 2-1 Unicode Character Translation
Escape Sequence Denotes _0XXXX a Unicode character XXXX. Note that lower case is used

- _0abcd as opposed to _0ABCD.
- _1     the character “_”
- _2     the character “;” in signatures
- _3     the character “[“ in signatures

*** 2.4 Native Method Arguments
    - JNI interface pointer is the *first arguments(JNIEnv*)* to native methods.
    - The *second argument* deffers depending on whether the native method is 
      *static(Java class) or nonstatic(jobject*)*
    - The *remaining arguments* correspond to regular java method arguments.
    see *Chapter 3*
#+BEGIN_SRC c
jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (
     JNIEnv *env,        /* interface pointer */
     jobject obj,        /* "this" pointer */
     jint i,             /* argument #1 */
     jstring s)          /* argument #2 */
{
     /* Obtain a C-copy of the Java string */
     const char *str = (*env)->GetStringUTFChars(env, s, 0);

     /* process the string */
     ...

     /* Now we are done with str */
     (*env)->ReleaseStringUTFChars(env, s, str);

     return ...
}
#+END_SRC
- 使用env操作java对象

*** 2.5 Referencing Java Objects(引用java对象)
    Primitive types, such as integers, characters, and so on, are copied between Java and native code. (原始类型互通)
     Arbitrary Java objects, on the other hand, are passed by reference.(引用java对象，
由虚拟机跟踪防止被垃圾回收)
**** Global and Local Reference(全局与局部引用)
     局部应用函数内有效，全局引用保持到被显式释放。
     所有JNI返回的Java对象都是局部引用。
     对象不能在线程间共享。
**** Implementing Local Reference
**** Accessing Java Objects
**** Accessing Primitive Arrays
**** Accessing Fields and Methods
     jmethodID mid = env->GetMethodID(cls,"f","ILjava/lang/String;)D");
     jdouble result = env->CallDoubleMethod(obj, mid, 10, string);
**** Reporting Programming Errors
**** Java Exceptions
     
** 3. JNI Types and Data Structures(JNI 类型与数据结构)
*** 3.1 Primitive Types(原始类型)
    | Java    | Native   | description |
    |---------+----------+-------------|
    | boolean | jboolean | uint8_t     |
    | byte    | jbyte    | int8_t      |
    | char    | jchar    | uint16_t    |
    | short   | jshort   | int16_t     |
    | int     | jint     | int32_t     |
    | long    | jlong    | int64_t     |
    | float   | jfloat   | 32bits      |
    | double  | double   | 64bits      |
    | void    | void     |             |
    |         |          |             | 
*** 3.2 Reference Types  
    jobject
     +- jclass  ; java.lang.Class
     +- jstring ; java.lang.Stirng
     +- jarray  ; arrays
     |   +- jobjectArray/booleanArray/... 
     \- jthrowable ; java.lang.Throwable

In C, all other JNI reference types are defined to be the same as jobject. For example:

typedef jobject jclass; 
In C++, JNI introduces a set of dummy classes to enforce the subtyping relationship. For example:

class _jobject {}; 
class _jclass : public _jobject {}; 
... 
typedef _jobject *jobject; 
typedef _jclass *jclass; 
*** Field and Method IDs
    struct _jfieldID;              /* opaque structure */ 
typedef struct _jfieldID *jfieldID;   /* field IDs */ 
 
struct _jmethodID;              /* opaque structure */ 
typedef struct _jmethodID *jmethodID; /* method IDs */ 
The Value Type
The jvalue union type is used as the element type in argument arrays. It is declared as follows:

typedef union jvalue { 
    jboolean z; 
    jbyte    b; 
    jchar    c; 
    jshort   s; 
    jint     i; 
    jlong    j; 
    jfloat   f; 
    jdouble  d; 
    jobject  l; 
} jvalue; 

*** Type Signatures
Table 3-2 Java VM Type Signatures
Type Signature
Java Type
Z boolean
B byte
C char
S short
I int
J long
F float
D double
L fully-qualified-class ; fully-qualified-class
[ type type[]
( arg-types ) ret-type method type
For example, the Java method:

long f (int n, String s, int[] arr); 
has the following type signature:

(ILjava/lang/String;[I)J 

*** Modified UTF-8 Strings
    
** 4. JNI Functions(JNI函数)
   https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html
*** Interface Function Table
    typedef const struct JNINativeInterface *JNIEnv;
** 5. The Invocation API
   #include <jni.h>       /* where everything is defined */
   ...
   JavaVM *jvm;       /* denotes a Java VM */
   JNIEnv *env;       /* pointer to native method interface */
   JavaVMInitArgs vm_args; /* JDK/JRE 6 VM initialization arguments */
   JavaVMOption* options = new JavaVMOption[1];
   options[0].optionString = "-Djava.class.path=/usr/lib/java";
   vm_args.version = JNI_VERSION_1_6;
   vm_args.nOptions = 1;
   vm_args.options = options;
   vm_args.ignoreUnrecognized = false;
   /* load and initialize a Java VM, return a JNI interface
     * pointer in env */
   JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);
   delete options;
   /* invoke the Main.test method using the JNI */
   jclass cls = env->FindClass("Main");
   jmethodID mid = env->GetStaticMethodID(cls, "test", "(I)V");
   env->CallStaticVoidMethod(cls, mid, 100);
   /* We are done. */
   jvm->DestroyJavaVM();

** 6. Demo
   #+BEGIN_SRC java
   /**
    ,* tstjni.java
    ,*/
   public class TstJni{
           public native void nativeApi(); /* C++ 中定义*/
           public int onJniCallBack(long x, long y){
                   /* C++ 回调JAVA */
                   return 1;
           }

           public native void asyncApi();
           public int onAsync(int i){
                   /* 其他线程回调 */
                   return 1;
           }

           public interface OnSub{
                   public int onCb(int i);
           };
           public native int nativeSub(String str, OnSub l);
           /*
            ,* tstjni.nativeSub("aaa", new OnSub(){
            ,*    @Override
            ,*    public int onCb(int i){return 0;}
            ,* });
            ,* tstjni.nativeSub("bbb", new OnSub(){
            ,*    @Override
            ,*    public int onCb(int i){return 1;}
            ,* });
            */
   }
   #+END_SRC
   #+BEGIN_SRC C
   #include <jni.h>

   JNIEXPORT void JNICALL Java_pkt_path_nativeApi(JNIEnv *env, jobject thiz){
           /* 获得Java类对象
            ,*/
           jclass tst_jni = env->GetOjbectClass(env, thiz); // tst_jni != 0
           jmethodID jcb = env->GetMethodID(env, tst_jni, "onJniCallBack", "(JJ)I");
           jint ret = env->CallIntMethos(env, thiz, jcb, 1, 2);
   }

   javaVM *g_vm;
   jobject g_obj;
   void proc_async(void *p);
   JNIEXPORT void JNICALL Java_pkt_path_asyncApi(JNIEnv *env, jobject thiz){
           env->GetJavaVM(env, &g_vm);
           g_obj = env->NewGlobalRef(env, thiz);
           pthread_create(NULL, NULL, proc_anync, NULL);
   }
   void proc_async(void *p){
           JNIEnv *env;
           int getEnvStat = g_vm->GetEnv(g_vm, (void**)&env, JNI_VERSION_1_6);
           if(getEnvStat == JNI_EDETACHED){
                   if(g_vm->AttachCurrentThread(g_vm, &env, NULL) != 0){return;}
           }
           jclass cls = env->GetObjectClass(env, g_obj);
           jmethodID jcb = env->GetMethodID(env, tst_jni, "onAsync", "(I)I");
           jint ret = env->CallIntMethos(env, thiz, jcb, 1);
           g_vm->DetachCurrentThread(g_vm);
   }

   JNIEXPORT void JNICALL Java_xxx_nativeDownload(JNIEnv *env, jobject thiz, jstring jpath, jobject jcallback) {
           jobject obj = env->GetGlobalRef(env, jcallback);
           pthread_create(NULL, NULL, proc, obj);
   }
   #+END_SRC
* developer.android.com
  https://developer.android.com/guide/components/fundamentals?hl=zh-cn
  中文版后缀 hl?=zh-cn
** App Basic(应用开发基础)
*** App fundamentals(应用基础知识 )
    APK(Android AacKage) = AndroidSDk.build(data,source)
    Security sandbox:
    - multi-user Linux system in which each app is a different user(1app1user).
    - By default, the system assigns each app a unique Linux user ID.
      The system set permissions for all the files in an app so that the
      user ID assigned to that app can access them(app用户控制文件访问权限)
    - Each process has its own virtual machine(VM), so an app's code runs in 
      isolation(隔离) from other apps;(每个app进程一个虚拟机)
    - By default, every app runs in tis own Linux process. The Android system
      starts the process when any of the app's components need to be executed,
      and then shuts down the process when it's no longer needed or when the
      system must recover memory for other apps.(app在自己的进程中运行,例外)

    The Android system implements the /principle of least privilege/
    最小权限法则. That is, each app, by default, has access only to the
    components that it requires to do its work and no more.
    This creates a very secure environment in which an app cannot access 
    parts of the system for which it is not given permission. However, There 
    are ways for an app to share data with other apps and for an app to access
    system services(app 共享数据和系统服务方式)
    - It's possible to arrange for two apps to share the same Linux user ID,
      in which case they are able to access each other's file. To conserve 
      (节约/保护)system resources, apps with the same user ID can also arrange
      (安排)to run the same Linux process and share the same VM. The app mast 
      also be signed with the same certificate(证书).
      app共享用户ID,从而共享文件,在同一进程,VM,但必须使用相同证书
    - An app can request permission to access device data such as the user's
      contacts(通讯录), SMS, the mountable storage(SD card), camera, and Bluetooth.
      app 可以请求设备访问权限.
      The user has to expliitly grant these permissions.权限必须用户授权
      https://developer.android.com/guide/topics/permissions/overview

    *concepts*
    - The core *framework components* that define your app.核心框架组件
    - The *manifest* file in which you declare the component and the required
      device features for your app.
    - *Resources* thar are separate from the app code and that allow your app
      to gracefully optimize its behavior for a variety of device configurations.
      资源文件独立与代码
**** App components(组件)
     *App components* are the essential building blocks of a Android app
     组件是app基础构建块. Each component is an *entry point* through which
     the system or a user enter your app系统或app入口点.
     
     There are four different types of app components:
     - Activities(活动,用户交互入口)
       An *activity* is the entry point for /interacting/ with the user.
       It represents a single screen with a user interface表现为单个屏幕.
       activity is independent of the other activity. a different app can start
       any one of these activities if the app allows it(活动独立，可授权其他应用开启)
     - Services(服务)
       A service is a general-purpose entry point for keeping an app running in the
       background for all kinds of reasons(后台应用入口). A Service does not provide 
       a user interface(无用户界面). For example, a service might play music in the
       background wihile the user is in a different app, or it might fetch data over
       the network without blocking user interaction with an activity(后台音乐/网络).
       Another component, such as an activity, can start the service and let it run
       or bind to it in order to interact with it(可有其他组件启动).
       - Sarted services tell the system to keep them running unitl their work is 
         completed.
     - Broadcast receivers(广播接收)
       A *broadcast receiver* is a component that enables the system to deliver
       events to the app outside of a regular user flow, allowing the app to 
       respond to system-wide broadcast announcements.
     - Content providers(内容提供组件)
       A *content provider* managers a shared set of app data that you can store
       in the file system, in a SQLite database, on the web, or on any other 
       persistent storage location that your app can access(存储公共数据).
       ContactsContract.Data
     
     Android apps don't have a single entry point(no main() function).
     your app cannot directly activate a component form another app.
     Android system can. To activate a component in another app, 
     deliver a message to the system that specifies your *intent* to 
     start a particular component(使用意图开启其他app下的组件).

**** Activating components(启动组件)
     Three of four components types *activites, services, broadcast receivers*
     are activated by an asynchronous message called an *intent*.
     *Intents* bind individual components to each other at runtime. Your can 
     think of them as the messengers that request an action from other componen
     -ts, whether the component belons to your app or another.
     An *intent* is created with an Intent object, which defines a message to 
     activate either a specific component or a specific type of component.

     For activities and services, an intent defines the action to perform and m
     ay specify the URI of data to act on, among other things that the componet
     being started might need to known.
     
     For broadcast receivers, the intent simply defines the announcement being 
     broadcast.

     content providers *are not activated* by intents. they are activated when
     targeted by a request from a *ContentResolver*

     There are separate methods for activating each type of component:
     - startActivity()/startActivityForResult()
     - With Android 5.0(API level 21) and later, JobScheduler to schedule actions
       startService()/bindService()
     - sendBroadcast()/sendOrderedBroadcast()/sendStickyBroadcast()
     - query() on a ContentResolver

**** The manifest file(文件清单)
     Before the Android system can start an app component, the system must know 
     that the component exists by reading the app's /manifest file/,
     *AndroidManifest.xml* Your app must declare all its components in this file,
     which must be at the root of the app project directory
     (在app项目根目录下Androidmanifest.xml申明所有组件).
     
     - Identifires any user permissions the app requiers, such as Internet acdess
       or read-access to the user's contacts(制定用户权限)
     - Declare the minimum API Level required by the app, based on which APIs the
       app uses(申明API等级).
     - Declare hardware and software features used or required by the app, such as
       a camera, bluetooth sercices, or a multitouch screen(申明软硬件需求).
     - Declares API libraries the app needs to be linked against(声明连接库).
***** Declaring components
      The primary task of the manifest is to inform the system about the app's components
      #+BEGIN_SRC xml
      <?xml version="1.0" encoding="utf-8"?>
      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.itc.aar2_app">

          <application
              android:allowBackup="true"
              android:icon="@mipmap/ic_launcher"
              android:label="@string/app_name"
              android:roundIcon="@mipmap/ic_launcher_round"
              android:supportsRtl="true"
              android:theme="@style/AppTheme">
              <!-- 声明活动 activities-->
              <activity android:name=".MainActivity">
                  <intent-filter>
                      <action android:name="android.intent.action.MAIN" />
                      <category android:name="android.intent.category.LAUNCHER" />
                  </intent-filter>
              </activity>
              <!-- 声明服务 services-->
              <service></service>
              <!-- 广播接收器 broadcast receivers-->
              <receiver></receiver>
              <!-- 内容提供组件 content providers-->
              <provider></provider>
          </application>

      </manifest>
      #+END_SRC
      Activities,services,and content providers that you include in your source but
      do not declare in the manifest are not visible to the system and consquently,
      can never run.
      However, broadcast receiver can be either declare int manifest or created
      dynamically in code as BroadcastReceiver objects and registered with the system
      by call registerReceiver().
      
***** Declaring component capabilities(功能声明)
      As discussed above, in Activating components, you can use an Intent to start
      activities, services and broadcast receivers. You can use an Intent by explicitly
      naming the target component in the intent. You can also use an implicit(隐式)
      intent which decribes the type of action to perform and optionally the data 
      upon which you'd like to perform the action.
      
      For example, if you build an email app with an activity for composing a new email,
      you can declare an intent filter to response to "send" intents(in order to send a
      new email)
      #+BEGIN_SRC xml
      <manifest ... >
          ...
          <application ... >
              <activity android:name="com.example.project.ComposeEmailActivity">
                  <intent-filter>
                      <action android:name="android.intent.action.SEND" />
                      <data android:type="*/*" />
                      <category android:name="android.intent.category.DEFAULT" />
                  </intent-filter>
              </activity>
          </application>
      </manifest>
      #+END_SRC
      If another app creates an intent with the /ACTION_SEND/ action and pass it to
      _startActivity()_, the system may start your activity so the user can draft 
      and send an email.
***** Decaring app requirements
      There are a variety of devices powered by Android and not all of them provide 
      the same feature and capabilities. The prevent your app from being installed 
      on devices that lack features needed by your app, it's important that your clearly
      define a profile for the types of device your app supports by declaring device
      and software requiremnts in you manifest file. Most of thest declarations are 
      informational only and system does not read them, but external services such 
      as Google Pay do read them in order to provide filtering for users when they 
      search for apps from their device.
      
      For example, if your app requires a camera and uses APIs introduced in Android 
      2.1, you mast declare these as requirements in your manifest file as shown in 
      the following example:
      #+BEGIN_SRC xml
      <manifest ... >
          <uses-feature android:name="android.hardware.camera.any"
                        android:required="true" />
          <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="19" />
          ...
      </manifest>
      #+END_SRC
      
**** App resources(应用资源)
     An Android app is composed of more then just code, it requires resources
     that are separate from the source code.
     Provideing sets of alternative resources enables your to optimize your 
     app for a variety of device configurations, such as different languages
     and screen sizes.(分离资源有利于定制设备配置，如语言、屏幕尺寸)

     For every resource that your include in your Android project, the SDK build
     tools define a unique integer ID(任何资源都对应一个ID, R.drawable.log)
*** App resources(App 资源)
    *Resources* are the additional files and static content that your can uses.
**** Grouping resource types(分组资源类型)
     src/
     res/
         drawable/ ; 位图 .png,.jpg,.gif
         layout/   ; 布局
         mipmap/   ; 启动图标
         values/   ; 字符串、整形、颜色等单值xml
         animator/ ; 熟悉动画
         anim/     ; 渐变动画
         color/    ; 颜色列表
         menu/     ; 菜单
         raw/      ; 原始文件 
         xml/      ; Resource.getXML()读取任意XML文件
**** 提供备用资源
     res/<resource_name>-<configure_qualifier>
     <resource_name> 默认资源目录名称
     <qualifier> 配置名称
     
     res/
         drawable/
              icon.png
              background.png
         drawable-hdbi/  ; 高密度屏
              icon.png
              background.png

     限定符名称
     | configure     | qualifier values         | description         |
     |---------------+--------------------------+---------------------|
     | MCC/MNC       | mcc310-mnc004美国Verizon | MCC移动国家代码     |
     |               | mcc208-mnc00法国Orange   | MNC移动网络代码     |
     |---------------+--------------------------+---------------------|
     | 语言和区域    | en/fr                    |                     |
     |               | en-rUS                   |                     |
     |---------------+--------------------------+---------------------|
     | 布局方向      | ldrtl/ldltr              | 从右到左/从左到右   |
     |               |                          | supportRtl=1        |
     |               |                          | targetSdkVerson>=17 |
     |---------------+--------------------------+---------------------|
     | smallestWidth | sw<N>dp                  | 屏幕基本尺寸        |
     |               | sw720dp                  |                     |
     |---------------+--------------------------+---------------------|
     | ...           |                          |                     |
     |---------------+--------------------------+---------------------|

**** 创建别名资源
     例如，假设您有一个应用图标 icon.png，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，您可以将用于二者的图像另存为 icon_ca.png（除 icon.png 以外的任何名称），并将其放入默认 res/drawable/ 目录中。然后，在 res/drawable-en-rCA/ 和 res/drawable-fr-rCA/ 中创建 icon.xml 文件，使用 <bitmap> 元素引用 icon_ca.png 资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。）
     @layout/main_ltr
**** 处理运行时变更
     有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。
     发生这种变化时，Android 会重启正在运行的 Activity
     （先后调用 onDestroy() 和 onCreate()）。
要妥善处理重启行为，Activity 必须通过常规的Activity 生命周期恢复其以前的状态，
在 Activity 生命周期中，Android 会在销毁 Activity 之前调用onSaveInstanceState()，
以便您保存有关应用状态的数据。 然后，您可以在onCreate() 或 
onRestoreInstanceState() 期间恢复 Activity 状态。
***** 在配置变更期间保留对象
      Fragment(片段)
      扩展 Fragment 类并声明对有状态对象的引用。
      在创建片段后调用 setRetainInstance(boolean)。
      将片段添加到 Activity。
      重启 Activity 后，使用 FragmentManager 检索片段。
      #+BEGIN_SRC java
      public class RetainedFragment extends Fragment {

          // data object we want to retain
          private MyDataObject data;

          // this method is only called once for this fragment
          @Override
          public void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              // retain this fragment
              setRetainInstance(true);
          }

          public void setData(MyDataObject data) {
              this.data = data;
          }

          public MyDataObject getData() {
              return data;
          }
      }
      #+END_SRC
注意：尽管您可以存储任何对象，但是切勿传递与 Activity 绑定的对象，
例如，Drawable、Adapter、View 或其他任何与 Context 关联的对象。
否则，它将泄漏原始 Activity 实例的所有视图和资源。 
（泄漏资源意味着应用将继续持有这些资源，但是无法对其进行垃圾回收，因此可能会丢失大量内存。）

#+BEGIN_SRC java
public class MyActivity extends Activity {

    private RetainedFragment dataFragment;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // find the retained fragment on activity restarts
        FragmentManager fm = getFragmentManager();
        dataFragment = (DataFragment) fm.findFragmentByTag(“data”);

        // create the fragment and data the first time
        if (dataFragment == null) {
            // add the fragment
            dataFragment = new DataFragment();
            fm.beginTransaction().add(dataFragment, “data”).commit();
            // load the data from the web
            dataFragment.setData(loadMyData());
        }

        // the data is available in dataFragment.getData()
        ...
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // store the data in the fragment
        dataFragment.setData(collectMyLoadedData());
    }
}
#+END_SRC
***** 自行处理配置变更(不建议)
如果应用在特定配置变更期间无需更新资源，并且因性能限制您需要尽量避免重启，
则可声明 Activity 将自行处理配置变更，这样可以阻止系统重启 Activity。

要声明由 Activity 处理配置变更，请在清单文件中编辑相应的 <activity> 元素，
以包含 android:configChanges 属性以及代表要处理的配置的值。
android:configChanges 属性的文档中列出了该属性的可能值（最常用的值包括 
"orientation" 和 "keyboardHidden"，分别用于避免因屏幕方向和可用键盘改变而
导致重启）。您可以在该属性中声明多个配置值，方法是用管道 | 字符分隔这些配置值。

<activity android:name=".MyActivity"
          android:configChanges="orientation|keyboardHidden"
          android:label="@string/app_name">

以下 onConfigurationChanged() 实现检查当前设备方向：
#+BEGIN_SRC java
@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    // Checks the orientation of the screen
    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        Toast.makeText(this, "landscape", Toast.LENGTH_SHORT).show();
    } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){
        Toast.makeText(this, "portrait", Toast.LENGTH_SHORT).show();
    }
}
#+END_SRC
*** App manifest file(应用清单)
每个应用的根目录中都必须包含一个 AndroidManifest.xml 文件（且文件名精确无误）。
 清单文件向 Android 系统提供应用的必要信息，系统必须具有这些信息方可运行应用的任何代码。

此外，清单文件还可执行以下操作：

为应用的 Java 软件包命名。软件包名称充当应用的唯一标识符。
描述应用的各个组件，包括构成应用的 Activity、服务、广播接收器和内容提供程序。
它还为实现每个组件的类命名并发布其功能，例如它们可以处理的 Intent 消息。
这些声明向 Android 系统告知有关组件以及可以启动这些组件的条件的信息。
确定托管应用组件的进程。
声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互。
还声明其他应用与该应用组件交互所需具备的权限列出 Instrumentation 类，这些类可在
应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前将移除。
声明应用所需的最低 Android API 级别
列出应用必须链接到的库

**** 清单文件结构
#+BEGIN_SRC xml
<?xml version="1.0" encoding="utf-8"?>

<manifest>

    <uses-permission />
    <permission />
    <permission-tree />
    <permission-group />
    <instrumentation />
    <uses-sdk />
    <uses-configuration />  
    <uses-feature />  
    <supports-screens />  
    <compatible-screens />  
    <supports-gl-texture />  

    <application>

        <activity>
            <intent-filter>
                <action />
                <category />
                <data />
            </intent-filter>
            <meta-data />
        </activity>

        <activity-alias>
            <intent-filter> . . . </intent-filter>
            <meta-data />
        </activity-alias>

        <service>
            <intent-filter> . . . </intent-filter>
            <meta-data/>
        </service>

        <receiver>
            <intent-filter> . . . </intent-filter>
            <meta-data />
        </receiver>

        <provider>
            <grant-uri-permission />
            <meta-data />
            <path-permission />
        </provider>

        <uses-library />

    </application>

</manifest>
#+END_SRC
**** 文件功能
***** Intent 过滤器
应用的核心组件（例如其 Activity、服务和广播接收器）由 intent 激活。
***** 图标和标签
***** 权限
如果应用需要访问受权限保护的功能，则必须在清单中使用 <uses-permission> 元素声明应用需要该权限
<uses-permission
     android:name="android.permission.WRITE_EXTERNAL_STORAGE"
     android:maxSdkVersion="18" />
这样，从 API 级别 19 开始，系统将不再向您的应用授予 WRITE_EXTERNAL_STORAGE 权限。
此属性为 API 级别 19 中新增属性。

*** App permissions(App权限)

** Core topics(核心提示)
*** Activities
**** Concept(基本概念)
***** The activity lifecycle(生命周期)
****** Guide to app atchitecture(app架构指导)
       https://developer.android.com/jetpack/docs/guide?hl=zh-cn
       Activity/Fragment
         \-> ViewModel(LiveData1/liveData2/...)
                 \-> Repository
                        \-> Model(Room)->SQLite
                         \-> Remote Data Source(Retrofit) -> webservice

      构建用户界面
      UI由片段UserProfileFragment及其对应的布局文件user_profile_layout.xml组成。
      要驱动UI，我们的数据模型需要包含以下数据元素：
      - 用户ID：用户的标识符。 最好使用片段参数将此信息传递到片段中。
        如果Android操作系统破坏了我们的流程，则会保留此信息，
        因此下次重新启动应用时ID就可用。
      - 用户对象：包含用户详细信息的数据类。

      我们使用基于ViewModel体系结构组件的UserProfileViewModel来保存此信息。
      - ViewModel
        ViewModel对象提供特定UI组件（如片段或活动）的数据，
        并包含与模型通信的数据处理业务逻辑。 例如，ViewModel可以调用其他组件来加载数据，
        它可以转发用户请求来修改数据。 ViewModel不了解UI组件，
        因此它不受配置更改的影响，例如在旋转设备时重新创建活动。

      我们现在定义了以下文件：
      - user_profile.xml：屏幕的UI布局定义。
      - UserProfileFragment：显示数据的UI控制器。
        #+BEGIN_SRC java
        public class UserProfileFragment extends Fragment {
            private static final String UID_KEY = "uid";
            private UserProfileViewModel viewModel;

            @Override
            public void onActivityCreated(@Nullable Bundle savedInstanceState) {
                super.onActivityCreated(savedInstanceState);
                String userId = getArguments().getString(UID_KEY);
                viewModel = ViewModelProviders.of(this).get(UserProfileViewModel.class);
                viewModel.init(userId);
            }

            @Override
            public View onCreateView(LayoutInflater inflater,
                        @Nullable ViewGroup container,
                        @Nullable Bundle savedInstanceState) {
                return inflater.inflate(R.layout.user_profile, container, false);
            }
        }
        #+END_SRC
      - UserProfileViewModel：准备数据以便在UserProfileFragment中查看并对用户交互作出反应的类。
        #+BEGIN_SRC java
        public class UserProfileViewModel extends ViewModel {
            private String userId;
            private User user;

            public void init(String userId) {
                this.userId = userId;
            }
            public User getUser() {
                return user;
            }
        }

        #+END_SRC

      LiveData 是一个可观察的数据持有者。 应用程序中的其他组件可以使用此> holder
      监视对象的更改，而无需在它们之间创建明确且严格的依赖关系路径。 
      LiveData组件还尊重应用程序组件的生命周期状态（如活动，片段和服务），
      并包括清除逻辑以防止对象泄漏和过多的内存消耗。
      相关库RxJava/Agera

      #+BEGIN_SRC java
      public class UserProfileViewModel extends ViewModel {
          ...
          //private User user;
          private LiveData<User> user; 
          public LiveData<User> getUser() {
              return user;
          }
      }
      #+END_SRC
      
      #+BEGIN_SRC java
      // UserProfileFragment
      @Override
      public void onActivityCreated(@Nullable Bundle savedInstanceState) {
          super.onActivityCreated(savedInstanceState);
          viewModel.getUser().observe(this, user -> {
            // Update UI.
            // Every time the user profile data is updated,
            // the onChanged() callback is invoked, and the UI is refreshed.
          });
      }
      #+END_SRC
      如果您熟悉使用可观察回调的其他库，您可能已经意识到我们没有覆盖片段的
      onStop（）方法来停止观察数据。 LiveData不需要此步骤，因为它可识别生命周期，
      这意味着除非片段处于活动状态，否则它不会调用onChanged（）回调;
      也就是说，它已收到onStart（）但尚未收到onStop（））。
      调用片段的onDestroy（）方法时，LiveData也会自动删除观察者。

      + Fetch data(获取数据)
        我们假设我们的后端提供REST API。 我们使用Retrofit库来访问我们的后端。
        http://square.github.io/retrofit/
        #+BEGIN_SRC java
        public interface Webservice {
            /**
             ,* @GET declares an HTTP GET request
             ,* @Path("user") annotation on the userId parameter marks it as a
             ,* replacement for the {user} placeholder in the @GET path
             ,*/
            @GET("/users/{user}")
            Call<User> getUser(@Path("user") String userId);
        }
        #+END_SRC
        ViewModel delegates the data-fetching process to a new module, a *repository*.

        *Repository* 存储库模块处理数据操作。
        它们提供了一个干净的API，以便应用程序的其余部分可以轻松地检索这些数据。
        他们知道从何处获取数据以及在更新数据时要进行的API调用。
        您可以将存储库视为不同数据源之间的调解器，例如持久性模型，Web服务和高速缓存。
        #+BEGIN_SRC java
        public class UserRepository {
            private Webservice webservice;
            // ...
            public LiveData<User> getUser(int userId) {
                // This isn't an optimal implementation. We'll fix it later.
                final MutableLiveData<User> data = new MutableLiveData<>();
                webservice.getUser(userId).enqueue(new Callback<User>() {
                    @Override
                    public void onResponse(Call<User> call, Response<User> response) {
                        data.setValue(response.body());
                    }

                    // Error case is left out for brevity.
                });
                return data;
            }
        }
        #+END_SRC
        即使存储库模块看起来不必要，它也有一个重要的目的：
        它从应用程序的其余部分抽象出数据源。   现在，
        我们的UserProfileViewModel不知道如何获取数据，
        因此我们可以为视图模型提供从几个不同的数据获取实现获得的数据。
      + Manage dependencies between components(管理数据组件依赖)
        您可以使用以下设计模式来解决此问题：
        依赖注入（DI）：依赖注入允许类在不构造它们的情况下定义它们的依赖关系。
        在运行时，另一个类负责提供这些依赖项。 
        我们建议使用Dagger 2库在Android应用程序中实现依赖注入。 
        Dagger 2通过遍历依赖树自动构造对象，并为依赖关系提供编译时保证。
        服务定位器：服务定位器模式提供了一个注册表，其中类可以获取它们的依赖关系而不是构造它们。
        实现服务注册表比使用DI更容易，因此如果您不熟悉DI，请改用服务定位器模式。
        
        Dagger2 to manage the Webservice object's
      + Connect ViewModel and repository(连接ViewModel和仓库)
        #+BEGIN_SRC java
        public class UserProfileViewModel extends ViewModel {
            private LiveData<User> user;
            private UserRepository userRepo;

            // Instructs Dagger 2 to provide the UserRepository parameter.
            @Inject
            public UserProfileViewModel(UserRepository userRepo) {
                this.userRepo = userRepo;
            }

            public void init(int userId) {
                if (this.user != null) {
                    // ViewModel is created on a per-Fragment basis, so the userId
                    // doesn't change.
                    return;
                }
                user = userRepo.getUser(userId);
            }

            public LiveData<User> getUser() {
                return this.user;
            }
        }
        #+END_SRC
      + Cache data
        后端数据需要缓存
        为了解决这些缺点，我们向UserRepository添加了一个新的数据源，它将User对象缓存在内存中：
        #+BEGIN_SRC java
        // Informs Dagger that this class should be constructed only once.
        @Singleton
        public class UserRepository {
            private Webservice webservice;

            // Simple in-memory cache. Details omitted for brevity.
            private UserCache userCache;

            public LiveData<User> getUser(int userId) {
                LiveData<User> cached = userCache.get(userId);
                if (cached != null) {
                    return cached;
                }

                final MutableLiveData<User> data = new MutableLiveData<>();
                userCache.put(userId, data);

                // This implementation is still suboptimal but better than before.
                // A complete implementation also handles error cases.
                webservice.getUser(userId).enqueue(new Callback<User>() {
                    @Override
                    public void onResponse(Call<User> call, Response<User> response) {
                        data.setValue(response.body());
                    }
                });
                return data;
            }
        }
        #+END_SRC
      + Persist data
        前面解决了数据缓存，但如果关闭进程后开启如何处理数据？
        *Room* library
        Room是一个对象映射库，提供本地数据持久性和最少的样板代码。
        在编译时，它根据您的数据模式验证每个查询，
        因此损坏的SQL查询会导致编译时错误而不是运行时失败。
        Room抽象了使用原始SQL表和查询的一些底层实现细节。
        它还允许您观察数据库数据的更改，包括集合和连接查询，使用LiveData对象公开此类更改。
        它甚至明确定义了解决常见线程问题的执行约束，例如访问主线程上的存储。
        如果您的应用已经使用了其他持久性解决方案，例如SQLite对象关系映射（ORM），
        则无需使用Room替换现有解决方案。
        但是，如果您正在编写新应用或重构现有应用，我们建议您使用Room来保留应用的数据。
        这样，您就可以利用库的抽象和查询验证功能。
        #+BEGIN_SRC java
        @Entity
        class User {
          @PrimaryKey
          private int id;
          private String name;
          private String lastName;

          // Getters and setters for fields.
        }

        @Database(entities = {User.class}, version = 1)
        public abstract class UserDatabase extends RoomDatabase {
        }

        @Dao
        public interface UserDao {
            @Insert(onConflict = REPLACE)
            void save(User user);
            @Query("SELECT * FROM user WHERE id = :userId")
            LiveData<User> load(int userId);
        }

        @Singleton
        public class UserRepository {
            private final Webservice webservice;
            private final UserDao userDao;
            private final Executor executor;

            @Inject
            public UserRepository(Webservice webservice, UserDao userDao, Executor executor) {
                this.webservice = webservice;
                this.userDao = userDao;
                this.executor = executor;
            }

            public LiveData<User> getUser(String userId) {
                refreshUser(userId);
                // Returns a LiveData object directly from the database.
                return userDao.load(userId);
            }

            private void refreshUser(final String userId) {
                // Runs in a background thread.
                executor.execute(() -> {
                    // Check if user data was fetched recently.
                    boolean userExists = userDao.hasUser(FRESH_TIMEOUT);
                    if (!userExists) {
                        // Refreshes the data.
                        Response<User> response = webservice.getUser(userId).execute();

                        // Check for errors here.

                        // Updates the database. The LiveData object automatically
                        // refreshes, so we don't need to do anything else here.
                        userDao.save(response.body());
                    }
                });
            }
        }
        #+END_SRC
      + Single source for truth
      + Show in-progress operations
        https://github.com/googlesamples/android-architecture-components/blob/88747993139224a4bb6dbe985adf652d557de621/GithubBrowserSample/app/src/main/java/com/android/example/github/repository/NetworkBoundResource.kt
      + Test each component
        - User interface and interactions
          https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests?hl=zh-cn

          https://developer.android.com/training/testing/ui-testing/espresso-testing?hl=zh-cn
        - ViewModel
          using JUnit test.
          https://developer.android.com/training/testing/unit-testing/local-unit-tests?hl=zh-cn
        - UserDao
          create an in-memory database to ensure that the test doesn't have any side effects,
          such as changing the database files on disk.(使用内存数据库测试)
          注意：Room允许指定数据库实现，因此可以通过提供SupportSQLiteOpenHelper
          的JUnit实现来测试DAO。 但是，不建议使用此方法，
          因为设备上运行的SQLite版本可能与开发计算机上的SQLite版本不同。
        - Webservice
          在这些测试中，避免向后端进行网络呼叫。
          对于所有测试，尤其是基于Web的测试，独立于外部世界非常重要。
          包括MockWebServer在内的几个库可以帮助您为这些测试创建虚假的本地服务器。
          https://github.com/square/okhttp/tree/master/mockwebserver
        - Testing Artifacts
          测试工件：Architecture Components提供了一个maven工件来控制其后台线程。
          android.arch.core：core-testing工件包含以下JUnit规则：
          InstantTaskExecutorRule：使用此规则立即执行调用线程上的任何后台操作。
          CountingTaskExecutorRule：使用此规则等待Architecture Components的后台操作。
          您还可以将此规则与Espresso关联为空闲资源。
      + Best practices(实践)
        - 避免将应用的入口点（如活动，服务和广播接收器）指定为数据源。
        - 在应用的各个模块之间创建明确定义的责任范围。
        - 从每个模块尽可能少地暴露。
        - 考虑如何使每个模块独立可测试。
        - 专注于您应用的独特核心，以便从其他应用中脱颖而出。
        - 保持尽可能多的相关和新鲜数据。
        - 将一个数据源指定为单一事实来源。
      + Addendum:exposing network status(暴露网络状态)
        Using a *Resource* class to expose network status.
        *Resource* class that encapsulate both the data and its state.
        #+BEGIN_SRC java
        // A generic class that contains data and status about loading this data.
        public class Resource<T> {
            @NonNull public final Status status;
            @Nullable public final T data;
            @Nullable public final String message;
            private Resource(@NonNull Status status, @Nullable T data,
                    @Nullable String message) {
                this.status = status;
                this.data = data;
                this.message = message;
            }

            public static <T> Resource<T> success(@NonNull T data) {
                return new Resource<>(Status.SUCCESS, data, null);
            }

            public static <T> Resource<T> error(String msg, @Nullable T data) {
                return new Resource<>(Status.ERROR, data, msg);
            }

            public static <T> Resource<T> loading(@Nullable T data) {
                return new Resource<>(Status.LOADING, data, null);
            }

            public enum Status { SUCCESS, ERROR, LOADING }
        }

        // ResultType: Type for the Resource data.
        // RequestType: Type for the API response.
        public abstract class NetworkBoundResource<ResultType, RequestType> {
            // Called to save the result of the API response into the database.
            @WorkerThread
            protected abstract void saveCallResult(@NonNull RequestType item);

            // Called with the data in the database to decide whether to fetch
            // potentially updated data from the network.
            @MainThread
            protected abstract boolean shouldFetch(@Nullable ResultType data);

            // Called to get the cached data from the database.
            @NonNull @MainThread
            protected abstract LiveData<ResultType> loadFromDb();

            // Called to create the API call.
            @NonNull @MainThread
            protected abstract LiveData<ApiResponse<RequestType>> createCall();

            // Called when the fetch fails. The child class may want to reset components
            // like rate limiter.
            @MainThread
            protected void onFetchFailed();

            // Returns a LiveData object that represents the resource that's implemented
            // in the base class.
            public final LiveData<Resource<ResultType>> getAsLiveData();
        }

        class UserRepository {
            Webservice webservice;
            UserDao userDao;

            public LiveData<Resource<User>> loadUser(final int userId) {
                return new NetworkBoundResource<User,User>() {
                    @Override
                    protected void saveCallResult(@NonNull User item) {
                        userDao.insert(item);
                    }

                    @Override
                    protected boolean shouldFetch(@Nullable User data) {
                        return rateLimiter.canFetch(userId)
                                && (data == null || !isFresh(data));
                    }

                    @NonNull @Override
                    protected LiveData<User> loadFromDb() {
                        return userDao.load(userId);
                    }

                    @NonNull @Override
                    protected LiveData<ApiResponse<User>> createCall() {
                        return webservice.getUser(userId);
                    }
                }.getAsLiveData();
            }
        }
        #+END_SRC
****** Activity-lifecycle concepts
- callbacks
  + onCreate() 只调用一次
  + onStart()
  + onResume()
  + onPause()
  + onStop()
  + onDestroy()
- Activity state and ejectin from memory
  |------------+-------------------------+--------------|
  | Likelyhood | Process sate            | Actity state |
  |------------+-------------------------+--------------|
  | Least      | Foreground              | Created      |
  |            |                         | Started      |
  |            |                         | Resumed      |
  | More       | Background(lost focos)  | Paused       |
  | Most       | Background(not visible) | Stoped       |
  |            | Empty                   | Destroyed    |
  |------------+-------------------------+--------------|
- Saving and restoring transient(瞬态) UI state(保存与恢复)
  ViewMode + onSaveInstanceState()
- Instance state
  Bundle 简单的恢复
  ViewMode + onSaveInstanceState() 恢复复杂数据
- Save simple, lightweight UI state using onSaveInstanceState()
  onSaveInstanceState()默认实现图层瞬间状态，如EditText/ListView滚动位置
  复杂点的需要 Bundle
  #+BEGIN_SRC java
  static final String STATE_SCORE = "playerScore";
  static final String STATE_LEVEL = "playerLevel";
  // ...


  @Override
  public void onSaveInstanceState(Bundle savedInstanceState) {
      // Save the user's current game state
      savedInstanceState.putInt(STATE_SCORE, mCurrentScore);
      savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);

      // Always call the superclass so it can save the view hierarchy state
      super.onSaveInstanceState(savedInstanceState);
  }
  #+END_SRC
- Restore activity UI state using saved instance state
  onCreate()/onRestoreInstancceSate() 接收相同的绑定数据
  一定要检测onCreate()参数，判断是新活动还是有恢复数据的活动
  #+BEGIN_SRC java
  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState) // Always call the superclass first

      // Check whether we're recreating a previously destroyed instance
      if (savedInstanceState != null) {
          with(savedInstanceState) {
              // Restore value of members from saved state
              currentScore = getInt(STATE_SCORE)
              currentLevel = getInt(STATE_LEVEL)
          }
      } else {
          // Probably initialize members with default values for a new instance
      }
      // ...
  }
  #+END_SRC
  也可以不在onCreate()中恢复数据，在onStart()后的onRestoreInstanceState()中实现
  可以避免每次都要在onCreate()时判断是否有恢复数据。
  #+BEGIN_SRC java
  public void onRestoreInstanceState(Bundle savedInstanceState) {
      // Always call the superclass so it can restore the view hierarchy
      super.onRestoreInstanceState(savedInstanceState);

      // Restore state members from saved instance
      mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
      mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
  }
  #+END_SRC
- Navigating between activities
  startActivity()/startActivityForResult()/Intent;
- Coordinating activities(协调活动)
  生命周期回调的顺序是明确定义的，特别是当两个活动在同一个进程（app）
  中而另一个正在启动另一个时。 以下是活动A启动活动B时发生的操作顺序：
  1. Activity A的onPause（）方法执行。
  2. 活动B的onCreate（），onStart（）和onResume（）方法按顺序执行。 
    （活动B现在具有用户关注点。）
  3. 然后，如果活动A在屏幕上不再可见，则执行onStop（）方法。
  这种可预测的生命周期回调序列允许您管理从一个活动到另一个活动的信息转换。
***** Activity state changes(状态转换)
****** Configuration change occors(发生配置变更)
       There are a number of events that can trigger a configuration change. 
       Perhaps the most prominent(突出的) example is a change between 
       portrait(纵向/肖像画) and landscape(横向/山水画) orientations. 
       Other cases that can cause configuration changes include changes to 
       language or input device.
       发生配置更改时，将销毁并重新创建活动。
       原始活动实例将触发onPause（），onStop（）和onDestroy（）回调。
       将创建一个新的活动实例，并触发onCreate（），onStart（）和onResume（）回调。

****** Handling multi-window cases(对窗口)
       https://developer.android.com/guide/topics/ui/multi-window?hl=zh-cn
****** Activity or dialog appears in foreground(活动或窗口前端显示)
       新活动部分覆盖老活动
       非覆盖的活动回调onPause()，重新获得焦点后回调onResume()
       新活动全部覆盖老活动
       onPause()->onStop(), onStart()->onResume()
****** User taps Back button(用户点击后退按钮)
       onPause()->onStop()->onDestroy()
       不会回调onSaveInstanceState()
       但回调onBackPressed() 可以在其中实现确认退出对话框。
****** System kills app process(系统杀死app进程)
       使用ViewModel缓存数据
***** Task and back stack(任务与后台堆栈)
      设备主屏幕是大多数任务的起始位置。 当用户触摸应用程序启动器中的图标
      （或主屏幕上的快捷方式）时，该应用程序的任务将进入前台。
      如果应用程序不存在任务（最近未使用该应用程序），
      则会创建一个新任务，该应用程序的“主”活动将作为堆栈中的根活动打开。
****** Managing Tasks
       In this regard, the principal <activity> attributes you can use are:

       taskAffinity
       launchMode
       allowTaskReparenting
       clearTaskOnLaunch
       alwaysRetainTaskState
       finishOnTaskLaunch
       And the principal intent flags you can use are:
       
       FLAG_ACTIVITY_NEW_TASK
       FLAG_ACTIVITY_CLEAR_TOP
       FLAG_ACTIVITY_SINGLE_TOP
       In the following sections, you'll see how you can use these manifest attributes 
       and intent flags to define how activities are associated with tasks 
       and how they behave in the back stack.
****** Defining launch modes
       - Using the manifest file(高优先级)
         <activity launchMode="standard">
         + standard (default)
           默认。 系统在启动它的任务中创建活动的新实例，并将意图路由到该实例。
           活动可以多次实例化，每个实例可以属于不同的任务，一个任务可以有多个实例。
         + "singleTop"
           例如，假设任务的后向堆栈由根活动A组成，活动B，C和D位于顶部（堆栈为A-B-C-D; D位于顶部）。
           意图到达类型D的活动。如果D具有默认的“标准”启动模式，则启动该类的新实例并且堆栈变为A-B-C-D-D。
           但是，如果D的启动模式是“singleTop”，则现有的D实例通过onNewIntent（）接收意图，
           因为它位于堆栈的顶部 - 堆栈仍然是A-B-C-D。
           但是，如果意图到达类型B的活动，则即使其启动模式为“singleTop”，也会将新的B实例添加到堆栈中。
         + singleTask
           系统创建新任务并在新任务的根目录下实例化活动。 但是，如果活动的实例已存在于单独的任务中，
           则系统会通过调用其onNewIntent（）方法将意图路由到现有实例，而不是创建新实例。 
           一次只能存在一个活动实例。
          注意：虽然活动在新任务中启动，但“后退”按钮仍会将用户返回到上一个活动。
         + "singleInstance"
           与“singleTask”相同，但系统不会在持有实例的任务中启动任何其他活动。 
           活动始终是其任务的唯一成员; 任何由此开始的活动都在一个单独的任务中打开。
           task now
       - Using Intent flags(低优先级)
**** Fragment(片段）
     Fragment 表示 Activity 中的行为或用户界面部分。
     您可以将多个片段组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个片段。
     您可以将片段视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以
     在 Activity 运行时添加或移除片段（有点像您可以在不同 Activity 中重复使用的“子 Activity”）。
     片段必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。
     
     当您将片段作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 
     ViewGroup 内部，并且片段会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明片段，
     将其作为 <fragment> 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 ViewGroup，
     利用应用代码进行插入。不过，片段并非必须成为 Activity 布局的一部分；
     您还可以将没有自己 UI 的片段用作 Activity 的不可见工作线程。
***** 设计原理
      通过将 Activity 布局分成片段，您可以在运行时修改 Activity 的外观，
      并在由 Activity 管理的返回栈中保留这些更改。
      
      例如，新闻应用可以使用一个片段在左侧显示文章列表，使用另一个片段在右侧显示文章。
      因此，用户不需要使用一个 Activity 来选择文章，然后使用另一个 Activity 来阅读文章，
      而是可以在同一个 Activity 内选择文章并进行阅读

      您应该将每个片段都设计为可重复使用的模块化 Activity 组件。
      也就是说，由于每个片段都会通过各自的生命周期回调来定义其自己的布局和行为，
      您可以将一个片段加入多个 Activity，因此，您应该采用可复用式设计，
      避免直接从某个片段直接操纵另一个片段。 这特别重要，
      因为模块化片段让您可以通过更改片段的组合方式来适应不同的屏幕尺寸。 

      仍然以新闻应用为例 — 在平板电脑尺寸的设备上运行时，该应用可以在 Activity A 中嵌入两个片段。
      不过，在手机尺寸的屏幕上，没有足以储存两个片段的空间，因此Activity A 只包括用于显示文章列表的片段，
      当用户选择文章时，它会启动Activity B，其中包括用于阅读文章的第二个片段。 因此，
      应用可通过重复使用不同组合的片段来同时支持平板电脑和手机，

***** 创建片段
      您必须创建 Fragment 的子类（或已有其子类）。Fragment 类的代码与 Activity 非常相似。
      它包含与 Activity 类似的回调方法，如 onCreate()、onStart()、onPause() 和 onStop()。
      实际上，如果您要将现有 Android 应用转换为使用片段，可能只需将代码从 Activity 的回调
      方法移入片段相应的回调方法中。 

      通常，您至少应实现以下生命周期方法：
      - onCreate()
        系统会在创建片段时调用此方法。您应该在实现内初始化您想在片段暂停或停止后恢复时保留的必需片段组件。 
      - onCreateView()
        系统会在片段首次绘制其用户界面时调用此方法。 要想为您的片段绘制 UI，您从此方法中返回的 
        View 必须是片段布局的根视图。如果片段未提供 UI，您可以返回 null。
      - onPause()
        系统将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。
        您通常应该在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。 
     
      您可能还想扩展几个子类，而不是 Fragment 基类：
      - DialogFragment
        显示浮动对话框。使用此类创建对话框可有效地替代使用 Activity 类中的对话框帮助程序方法，
        因为您可以将片段对话框纳入由 Activity 管理的片段返回栈，从而使用户能够返回清除的片段。 
      - ListFragment
        显示由适配器（如 SimpleCursorAdapter）管理的一系列项目，类似于 ListActivity。
        它提供了几种管理列表视图的方法，如用于处理点击事件的 onListItemClick() 回调。
      - PreferenceFragment
        以列表形式显示 Preference 对象的层次结构，类似于 PreferenceActivity。
        这在为您的应用创建“设置” Activity 时很有用处。 

***** 添加用户界面
      片段通常用作 Activity 用户界面的一部分，将其自己的布局融入 Activity。 
      要想为片段提供布局，您必须实现 onCreateView() 回调方法，Android 系统会在片段需要绘制
      其布局时调用该方法。您对此方法的实现返回的 View 必须是片段布局的根视图。
      
      如果您的片段是 ListFragment 的子类，则默认实现会从 onCreateView() 返回一个 ListView，
      因此您无需实现它。

      要想从 onCreateView() 返回布局，您可以通过 XML 中定义的布局资源来扩展布局。
      为帮助您执行此操作，onCreateView() 提供了一个 LayoutInflater 对象。

      #+BEGIN_SRC java
      // 以下这个 Fragment 子类从 example_fragment.xml 文件加载布局
      public static class ExampleFragment extends Fragment {
          @Override
          public View onCreateView(LayoutInflater inflater, ViewGroup container,
                                   Bundle savedInstanceState) {
              // Inflate the layout for this fragment
              return inflater.inflate(R.layout.example_fragment, container, false);
          }
      }
      #+END_SRC
***** 向 Activity 添加片段
      片段向宿主 Activity 贡献一部分 UI，作为 Activity 总体视图层次结构的一部分嵌入到 Activity 中。
      可以通过两种方式向 Activity 布局添加片段
****** 在 Activity 的布局文件内声明片段
       #+BEGIN_SRC xml
       <?xml version="1.0" encoding="utf-8"?>
       <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
           android:orientation="horizontal"
           android:layout_width="match_parent"
           android:layout_height="match_parent">
           <fragment android:name="com.example.news.ArticleListFragment"
                   android:id="@+id/list"
                   android:layout_weight="1"
                   android:layout_width="0dp"
                   android:layout_height="match_parent" />
           <fragment android:name="com.example.news.ArticleReaderFragment"
                   android:id="@+id/viewer"
                   android:layout_weight="2"
                   android:layout_width="0dp"
                   android:layout_height="match_parent" />
       </LinearLayout>
       #+END_SRC
****** 过编程方式将片段添加到某个现有 ViewGroup
       您可以在 Activity 运行期间随时将片段添加到 Activity 布局中。您只需指定要将片段放入哪个 ViewGroup。
       要想在您的 Activity 中执行片段事务（如添加、移除或替换片段），
       您必须使用 FragmentTransaction 中的 API。您可以像下面这样从 Activity 获取一个
       FragmentTransaction 实例：
       #+BEGIN_SRC java
       FragmentManager fragmentManager = getFragmentManager();
       FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
       ExampleFragment fragment = new ExampleFragment();
       fragmentTransaction.add(R.id.fragment_container, fragment);
       fragmentTransaction.commit();
       #+END_SRC

****** 添加没有 UI 的片段
       您还可以使用片段为 Activity 提供后台行为，而不显示额外 UI。 
       请使用 add(Fragment, String) 从 Activity 添加片段
       （为片段提供一个唯一的字符串“标记”，而不是视图 ID）。 
        
       这会添加片段，但由于它并不与 Activity 布局中的视图关联，因此不会收到对 onCreateView() 的调用。
       因此，您不需要实现该方法。
       如果您想稍后从 Activity 中获取片段，则需要使用 findFragmentByTag()。

       如需查看将没有 UI 的片段用作后台工作线程的示例 Activity，请参阅 
       FragmentRetainInstance.java 示例，该示例包括在 SDK 示例（通过 Android SDK 管理器提供）中，以
       <sdk_root>/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java 
       形式位于您的系统中。

***** 片段管理
      要想管理您的 Activity 中的片段，您需要使用 FragmentManager。要想获取它，
      请从您的 Activity 调用 getFragmentManager()。

      您可以使用 FragmentManager 执行的操作包括：

      通过 findFragmentById()（对于在 Activity 布局中提供 UI 的片段）或
      findFragmentByTag()（对于提供或不提供 UI 的片段）获取 Activity 中存在的片段。
      通过 popBackStack()（模拟用户发出的返回命令）将片段从返回栈中弹出。
      通过 addOnBackStackChangedListener() 注册一个侦听返回栈变化的侦听器。

      如上文所示，您也可以使用 FragmentManager 打开一个
      FragmentTransaction，通过它来执行某些事务，如添加和移除片段。
***** 执行片段事务
      在 Activity 中使用片段的一大优点是，可以根据用户行为通过它们执行添加、移除、替换以及其他操作。
      您提交给 Activity 的每组更改都称为事务，您可以使用 FragmentTransaction 中的 API 来执行一项事务。
      您也可以将每个事务保存到由 Activity 管理的返回栈内，从而让用户能够回退片段更改
      （类似于回退 Activity）。 

      每个事务都是您想要同时执行的一组更改。您可以使用 add()、remove() 和 replace()
      等方法为给定事务设置您想要执行的所有更改。然后，要想将事务应用到 Activity，您必须调用 commit()。

      不过，在您调用 commit() 之前，您可能想调用 addToBackStack()，以将事务添加到片段事务返回栈。
      该返回栈由 Activity 管理，允许用户通过按返回按钮返回上一片段状态。 

      如果您要向同一容器添加多个片段，则您添加片段的顺序将决定它们在视图层次结构中的出现顺序 

      对于每个片段事务，您都可以通过在提交前调用 setTransition() 来应用过渡动画。
      #+BEGIN_SRC java
      // Create new fragment and transaction
      Fragment newFragment = new ExampleFragment();
      FragmentTransaction transaction = getFragmentManager().beginTransaction();

      // Replace whatever is in the fragment_container view with this fragment,
      // and add the transaction to the back stack
      transaction.replace(R.id.fragment_container, newFragment);
      transaction.addToBackStack(null);

      transaction.setTransition(); // 应用过渡动画
      // Commit the transaction
      transaction.commit();
      #+END_SRC

      调用 commit() 不会立即执行事务，而是在 Activity 的 UI 线程（“主”线程）
      可以执行该操作时再安排其在线程上运行。不过，如有必要，您也可以从 UI 线程调用
      executePendingTransactions() 以立即执行 commit()提交的事务。
      通常不必这样做，除非其他线程中的作业依赖该事务。 

      您只能在 Activity 保存其状态（用户离开 Activity）之前使用 commit() 提交事务。
      如果您试图在该时间点后提交，则会引发异常。 这是因为如需恢复 Activity，则提交后的状态
      可能会丢失。 对于丢失提交无关紧要的情况，请使用 commitAllowingStateLoss()。  

***** 与Activity通信
      片段可以通过 getActivity() 访问 Activity 实例，并轻松地执行在 Activity 布局中查找视图等任务。
      View listView = getActivity().findViewById(R.id.list);
      
      您的 Activity 也可以使用 findFragmentById() 或 findFragmentByTag()，
      通过从 FragmentManager 获取对 Fragment 的引用来调用片段中的方法。
      ExampleFragment fragment = (ExampleFragment)
      getFragmentManager().findFragmentById(R.id.example_fragment);
***** 创建对 Activity 的事件回调
      在某些情况下，您可能需要通过片段与 Activity 共享事件。
      执行此操作的一个好方法是，在片段内定义一个回调接口，并要求宿主 Activity 实现它。 
      当 Activity 通过该接口收到回调时，可以根据需要与布局中的其他片段共享这些信息。 

      如果一个新闻应用的 Activity 有两个片段 — 一个用于显示文章列表（片段 A），
      另一个用于显示文章（片段 B）— 那么片段 A 必须在列表项被选定后告知 Activity，
      以便它告知片段 B 显示该文章。 在本例中，OnArticleSelectedListener 接口在片段 A 内声明：
      #+BEGIN_SRC java
      public static class FragmentA extends ListFragment {
          ...
          // Container Activity must implement this interface
          public interface OnArticleSelectedListener {
              public void onArticleSelected(Uri articleUri);
          }
          ...
      }
      #+END_SRC
      
      然后，该片段的宿主 Activity 会实现 OnArticleSelectedListener 接口并替代 onArticleSelected()，
      将来自片段 A 的事件通知片段 B。为确保宿主 Activity 实现此接口，
      片段 A 的 onAttach() 回调方法（系统在向 Activity 添加片段时调用的方法）
      会通过转换传递到 onAttach() 中的 Activity 来实例化 OnArticleSelectedListener 的实例
      #+BEGIN_SRC java
      public static class FragmentA extends ListFragment {
          OnArticleSelectedListener mListener;
          ...
          @Override
          public void onAttach(Activity activity) {
              super.onAttach(activity);
              try {
                  mListener = (OnArticleSelectedListener) activity;
              } catch (ClassCastException e) {
                  throw new ClassCastException(activity.toString() + " must implement OnArticleSelectedListener");
              }
          }
          ...
      }
      #+END_SRC
      
      #+BEGIN_SRC java
      public static class FragmentA extends ListFragment {
          OnArticleSelectedListener mListener;
          ...
          @Override
          public void onListItemClick(ListView l, View v, int position, long id) {
              // Append the clicked item's row ID with the content provider Uri
              Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
              // Send the event and Uri to the host activity
              mListener.onArticleSelected(noteUri);
          }
          ...
      }
      #+END_SRC
      传递到 onListItemClick() 的 id 参数是被点击项的行 ID，
      即 Activity（或其他片段）用来从应用的 ContentProvider 获取文章的 ID。

***** 向应用栏添加项目
      您的片段可以通过实现 onCreateOptionsMenu() 向 Activity 的选项菜单（并因此向应用栏）
      贡献菜单项。不过，为了使此方法能够收到调用，您必须在 onCreate() 期间调用 setHasOptionsMenu()，
      以指示片段想要向选项菜单添加菜单项（否则，片段将不会收到对 onCreateOptionsMenu() 的调用）。
      您之后从片段添加到选项菜单的任何菜单项都将追加到现有菜单项之后。 
      选定菜单项时，片段还会收到对 onOptionsItemSelected() 的回调。
      您还可以通过调用 registerForContextMenu()，在片段布局中注册一个视图来提供上下文菜单。
      用户打开上下文菜单时，片段会收到对 onCreateContextMenu() 的调用。
      当用户选择某个菜单项时，片段会收到对 onContextItemSelected() 的调用。
      
***** 片段生命周期
      管理片段生命周期与管理 Activity 生命周期很相似。和 Activity 一样，片段也以三种状态存在：

      继续
        片段在运行中的 Activity 中可见。
      暂停
        另一个 Activity 位于前台并具有焦点，但此片段所在的 Activity 仍然可见
        （前台 Activity 部分透明，或未覆盖整个屏幕）。 
      停止
        片段不可见。宿主 Activity 已停止，或片段已从 Activity 中移除，但已添加到返回栈。
        停止片段仍然处于活动状态（系统会保留所有状态和成员信息）。 
        不过，它对用户不再可见，如果 Activity 被终止，它也会被终止。 

      |----------------+---------------------|
      | Activity State | Fragment Callbacks  |
      |----------------+---------------------|
      | Created        | onAttach()          |
      |                | onCreate()          |
      |                | onCreateView()      |
      |                | onActivityCreated() |
      | Started        | onStart()           |
      | Resumed        | onResume()          |
      | Paused         | onPause()           |
      | Stopped        | onStop()            |
      | Destroyed      | onDestroyView()     |
      |                | onDestroy()         |
      |                | onDetach()          |
      |----------------+---------------------|
      
      同样与 Activity 一样，假使 Activity 的进程被终止，而您需要在重建 Activity时恢复片段状态，
      您也可以使用 Bundle 保留片段的状态。
      您可以在片段的 onSaveInstanceState() 回调期间保存状态，
      并可在 onCreate()、onCreateView() 或 onActivityCreated() 期间恢复状态。

***** 与 Activity 生命周期协调一致
***** 示例
       下面的 Activity 包括两个片段：一个用于显示莎士比亚戏剧标题列表，
       另一个用于从列表中选定戏剧时显示其摘要。
       此外，它还展示了如何根据屏幕配置提供不同的片段配置。 
       FragmentLayout.java 中提供了此 Activity 的完整源代码。 
       #+BEGIN_SRC java
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);

           setContentView(R.layout.fragment_layout);
       }
       #+END_SRC

       res/layout-land/fragment_layout.xml
       #+BEGIN_SRC xml
       <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
           android:orientation="horizontal"
           android:layout_width="match_parent" android:layout_height="match_parent">

           <fragment class="com.example.android.apis.app.FragmentLayout$TitlesFragment"
                   android:id="@+id/titles" android:layout_weight="1"
                   android:layout_width="0px" android:layout_height="match_parent" />

           <FrameLayout android:id="@+id/details" android:layout_weight="1"
                   android:layout_width="0px" android:layout_height="match_parent"
                   android:background="?android:attr/detailsElementBackground" />

       </LinearLayout>
       #+END_SRC

       res/layout/fragment_layout.xml
       #+BEGIN_SRC xml
       <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
           android:layout_width="match_parent" android:layout_height="match_parent">
           <fragment class="com.example.android.apis.app.FragmentLayout$TitlesFragment"
                   android:id="@+id/titles"
                   android:layout_width="match_parent" android:layout_height="match_parent" />
       </FrameLayout>
       #+END_SRC
       
       TitlesFragment.java
       #+BEGIN_SRC java
       public static class TitlesFragment extends ListFragment {
           boolean mDualPane;
           int mCurCheckPosition = 0;

           @Override
           public void onActivityCreated(Bundle savedInstanceState) {
               super.onActivityCreated(savedInstanceState);

               // Populate list with our static array of titles.
               setListAdapter(new ArrayAdapter<String>(getActivity(),
                       android.R.layout.simple_list_item_activated_1, Shakespeare.TITLES));

               // Check to see if we have a frame in which to embed the details
               // fragment directly in the containing UI.
               View detailsFrame = getActivity().findViewById(R.id.details);
               mDualPane = detailsFrame != null && detailsFrame.getVisibility() == View.VISIBLE;

               if (savedInstanceState != null) {
                   // Restore last state for checked position.
                   mCurCheckPosition = savedInstanceState.getInt("curChoice", 0);
               }

               if (mDualPane) {
                   // In dual-pane mode, the list view highlights the selected item.
                   getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
                   // Make sure our UI is in the correct state.
                   showDetails(mCurCheckPosition);
               }
           }

           @Override
           public void onSaveInstanceState(Bundle outState) {
               super.onSaveInstanceState(outState);
               outState.putInt("curChoice", mCurCheckPosition);
           }

           @Override
           public void onListItemClick(ListView l, View v, int position, long id) {
               showDetails(position);
           }

           /**
            ,* Helper function to show the details of a selected item, either by
            ,* displaying a fragment in-place in the current UI, or starting a
            ,* whole new activity in which it is displayed.
            ,*/
           void showDetails(int index) {
               mCurCheckPosition = index;

               if (mDualPane) {
                   // We can display everything in-place with fragments, so update
                   // the list to highlight the selected item and show the data.
                   getListView().setItemChecked(index, true);

                   // Check what fragment is currently shown, replace if needed.
                   DetailsFragment details = (DetailsFragment)
                           getFragmentManager().findFragmentById(R.id.details);
                   if (details == null || details.getShownIndex() != index) {
                       // Make new fragment to show this selection.
                       details = DetailsFragment.newInstance(index);

                       // Execute a transaction, replacing any existing fragment
                       // with this one inside the frame.
                       FragmentTransaction ft = getFragmentManager().beginTransaction();
                       if (index == 0) {
                           ft.replace(R.id.details, details);
                       } else {
                           ft.replace(R.id.a_item, details);
                       }
                       ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
                       ft.commit();
                   }

               } else {
                   // Otherwise we need to launch a new activity to display
                   // the dialog fragment with selected text.
                   Intent intent = new Intent();
                   intent.setClass(getActivity(), DetailsActivity.class);
                   intent.putExtra("index", index);
                   startActivity(intent);
               }
           }
       }
       #+END_SRC

       DetailsFragment.java
       #+BEGIN_SRC java
       public static class DetailsFragment extends Fragment {
           /**
            ,* Create a new instance of DetailsFragment, initialized to
            ,* show the text at 'index'.
            ,*/
           public static DetailsFragment newInstance(int index) {
               DetailsFragment f = new DetailsFragment();

               // Supply index input as an argument.
               Bundle args = new Bundle();
               args.putInt("index", index);
               f.setArguments(args);

               return f;
           }

           public int getShownIndex() {
               return getArguments().getInt("index", 0);
           }

           @Override
           public View onCreateView(LayoutInflater inflater, ViewGroup container,
                   Bundle savedInstanceState) {
               if (container == null) {
                   // We have different layouts, and in one of them this
                   // fragment's containing frame doesn't exist.  The fragment
                   // may still be created from its saved state, but there is
                   // no reason to try to create its view hierarchy because it
                   // won't be displayed.  Note this is not needed -- we could
                   // just run the code below, where we would create and return
                   // the view hierarchy; it would just never be used.
                   return null;
               }

               ScrollView scroller = new ScrollView(getActivity());
               TextView text = new TextView(getActivity());
               int padding = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
                       4, getActivity().getResources().getDisplayMetrics());
               text.setPadding(padding, padding, padding, padding);
               scroller.addView(text);
               text.setText(Shakespeare.DIALOGUE[getShownIndex()]);
               return scroller;
           }
       }
       #+END_SRC
       
       DetailsActivity.java
       #+BEGIN_SRC java
       public static class DetailsActivity extends Activity {

           @Override
           protected void onCreate(Bundle savedInstanceState) {
               super.onCreate(savedInstanceState);

               if (getResources().getConfiguration().orientation
                       == Configuration.ORIENTATION_LANDSCAPE) {
                   // If the screen is now in landscape mode, we can show the
                   // dialog in-line with the list so we don't need this activity.
                   finish();
                   return;
               }

               if (savedInstanceState == null) {
                   // During initial setup, plug in the details fragment.
                   DetailsFragment details = new DetailsFragment();
                   details.setArguments(getIntent().getExtras());
                   getFragmentManager().beginTransaction().add(android.R.id.content, details).commit();
               }
           }
       }
       #+END_SRC
***** Building a flexible UI(构建灵活的UI)
      FragmentManager 类提供的方法让您可以在运行时为 Activity
      添加、移除和替换片段，从而营造出动态的用户体验。
***** Communicating with Other Fragments
****** Define an Interface
       #+BEGIN_SRC java
       public class HeadlinesFragment extends ListFragment {
           OnHeadlineSelectedListener mCallback;

           // Container Activity must implement this interface
           public interface OnHeadlineSelectedListener {
               public void onArticleSelected(int position);
           }

           @Override
           public void onAttach(Activity activity) {
               super.onAttach(activity);

               // This makes sure that the container activity has implemented
               // the callback interface. If not, it throws an exception
               try {
                   mCallback = (OnHeadlineSelectedListener) activity;
               } catch (ClassCastException e) {
                   throw new ClassCastException(activity.toString()
                           + " must implement OnHeadlineSelectedListener");
               }
           }

           @Override
           public void onListItemClick(ListView l, View v, int position, long id) {
               // Send the event to the host activity
               mCallback.onArticleSelected(position);
           }
           ...
       }
       #+END_SRC
****** Implement the interface
       #+BEGIN_SRC java
       public static class MainActivity extends Activity
               implements HeadlinesFragment.OnHeadlineSelectedListener{
           ...

           public void onArticleSelected(int position) {
               // The user selected the headline of an article from the HeadlinesFragment
               // Do something here to display that article
           }
       }
       #+END_SRC
****** Deliver a Message to a Fragment(投递消息到片段)
       #+BEGIN_SRC java
       public static class MainActivity extends Activity
               implements HeadlinesFragment.OnHeadlineSelectedListener{
           ...

           public void onArticleSelected(int position) {
               // The user selected the headline of an article from the HeadlinesFragment
               // Do something here to display that article

               ArticleFragment articleFrag = (ArticleFragment)
                       getSupportFragmentManager().findFragmentById(R.id.article_fragment);

               if (articleFrag != null) {
                   // If article frag is available, we're in two-pane layout...

                   // Call a method in the ArticleFragment to update its content
                   articleFrag.updateArticleView(position);
               } else {
                   // Otherwise, we're in the one-pane layout and must swap frags...

                   // Create fragment and give it an argument for the selected article
                   ArticleFragment newFragment = new ArticleFragment();
                   Bundle args = new Bundle();
                   args.putInt(ArticleFragment.ARG_POSITION, position);
                   newFragment.setArguments(args);

                   FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();

                   // Replace whatever is in the fragment_container view with this fragment,
                   // and add the transaction to the back stack so the user can navigate back
                   transaction.replace(R.id.fragment_container, newFragment);
                   transaction.addToBackStack(null);

                   // Commit the transaction
                   transaction.commit();
               }
           }
       }
       #+END_SRC
**** Interactive with other apps(与其他App交互)
     #+BEGIN_SRC java
     // 带验证打开地图
     // Build the intent
     Uri location = Uri.parse("geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California");
     Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);

     // Verify it resolves
     PackageManager packageManager = getPackageManager();
     List<ResolveInfo> activities = packageManager.queryIntentActivities(mapIntent, 0);
     boolean isIntentSafe = activities.size() > 0;

     // Start an activity if it's safe
     if (isIntentSafe) {
         startActivity(mapIntent);
     }

     // 发送电子邮件意图
     Intent emailIntent = new Intent(Intent.ACTION_SEND);
     // The intent does not have a URI, so declare the "text/plain" MIME type
     emailIntent.setType(HTTP.PLAIN_TEXT_TYPE);
     emailIntent.putExtra(Intent.EXTRA_EMAIL, new String[] {"jon@example.com"}); // recipients
     emailIntent.putExtra(Intent.EXTRA_SUBJECT, "Email subject");
     emailIntent.putExtra(Intent.EXTRA_TEXT, "Email message text");
     emailIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse("content://path/to/email/attachment"));
     // You can also attach multiple items by passing an ArrayList of Uris

     // 创建日历事件意图
     Intent calendarIntent = new Intent(Intent.ACTION_INSERT, Events.CONTENT_URI);
     Calendar beginTime = Calendar.getInstance().set(2012, 0, 19, 7, 30);
     Calendar endTime = Calendar.getInstance().set(2012, 0, 19, 10, 30);
     calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, beginTime.getTimeInMillis());
     calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, endTime.getTimeInMillis());
     calendarIntent.putExtra(Events.TITLE, "Ninja class");
     calendarIntent.putExtra(Events.EVENT_LOCATION, "Secret dojo");
     #+END_SRC
***** 显示应用选择器
      #+BEGIN_SRC java
      Intent intent = new Intent(Intent.ACTION_SEND);
      ///...

      // Always use string resources for UI text.
      // This says something like "Share this photo with"
      String title = getResources().getString(R.string.chooser_title);
      // Create intent to show chooser
      Intent chooser = Intent.createChooser(intent, title);

      // Verify the intent will resolve to at least one activity
      if (intent.resolveActivity(getPackageManager()) != null) {
          startActivity(chooser);
      }
      #+END_SRC
**** Getting a result from an activity(获得activity返回值)
***** 启动Activyty
     启动并不一定是单向的另一个 Activity。您还可以启动另一个 Activity 并 接收返回的结果。
     要接收结果，请调用 startActivityForResult()（而不是 startActivity()）。

     响应的 Activity 必须设计为返回结果。当它这样做时，它会作为另一 Intent 对象发送结果。
     您的 Activity 在 onActivityResult() 回调中接收它。

     当您调用 startActivityForResult() 时，您可以使用明确或隐含 Intent。
     当启动您自己的 Activity 以接收结果时，您应使用明确 Intent 确保您可收到预期结果。 

     #+BEGIN_SRC java
     // 此处显示如何开始允许用户选择联系人的 Activity
     static final int PICK_CONTACT_REQUEST = 1;  // The request code
     //...
     private void pickContact() {
         Intent pickContactIntent = new Intent(Intent.ACTION_PICK, Uri.parse("content://contacts"));
         pickContactIntent.setType(Phone.CONTENT_TYPE); // Show user only contacts w/ phone numbers
         startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);
     }
     #+END_SRC
***** 接收结果
      当用户完成后续 Activity 并且返回时，系统会调用您的 Activity 
      onActivityResult() 的方法。此方法包括三个参数：

      您向 startActivityForResult() 传递的请求代码。
      第二个 Activity 指定的结果代码。如果操作成功，这是 RESULT_OK；
      如果用户退出或操作出于某种原因失败，则是 RESULT_CANCELED。
      传送结果数据的 Intent。

      #+BEGIN_SRC java
      // 本例说明您可以如何处理“选择联系人” Intent 的结果
      @Override
      protected void onActivityResult(int requestCode, int resultCode, Intent data) {
          // Check which request we're responding to
          if (requestCode == PICK_CONTACT_REQUEST) {
              // Make sure the request was successful
              if (resultCode == RESULT_OK) {
                  // The user picked a contact.
                  // The Intent's data Uri identifies which contact was selected.

                  // Do something with the contact here (bigger example below)
              }
          }
      }
      #+END_SRC
****** 奖励：读取联系人数据
       显示如何从“联系人”应用获取结果的代码不会详细说明
       如何实际从结果读取数据，但它需要对内容提供程序进行更深入的探讨。
       但是，如果您很好奇，此处提供了更多的代码向您展示如何查询结果数据，
       从所选联系人获取电话号码： 
       #+BEGIN_SRC java
       @Override
       protected void onActivityResult(int requestCode, int resultCode, Intent data) {
           // Check which request it is that we're responding to
           if (requestCode == PICK_CONTACT_REQUEST) {
               // Make sure the request was successful
               if (resultCode == RESULT_OK) {
                   // Get the URI that points to the selected contact
                   Uri contactUri = data.getData();
                   // We only need the NUMBER column, because there will be only one row in the result
                   String[] projection = {Phone.NUMBER};

                   // Perform the query on the contact to get the NUMBER column
                   // We don't need a selection or sort order (there's only one result for the given URI)
                   // CAUTION: The query() method should be called from a separate thread to avoid blocking
                   // your app's UI thread. (For simplicity of the sample, this code doesn't do that.)
                   // Consider using CursorLoader to perform the query.
                   Cursor cursor = getContentResolver()
                           .query(contactUri, projection, null, null, null);
                   cursor.moveToFirst();

                   // Retrieve the phone number from the NUMBER column
                   int column = cursor.getColumnIndex(Phone.NUMBER);
                   String number = cursor.getString(column);

                   // Do something with the phone number...
               }
           }
       }
       #+END_SRC

**** Allowing other apps to start your activity(允许其他app启动你的activity)
     如果您构建一款可与用户的好友分享消息或照片的社交应用，您最关注的是支持 ACTION_SEND Intent 
     以便用户可以从另一应用发起“共享”操作并且启动您的应用执行该操作。 

     要允许其他应用启动您的 Activity，您需要在清单文件中为对应的 <activity> 元素
     添加一个 <intent-filter> 元素。
***** 添加 Intent 过滤器
      - 操作
        对要执行的操作命名的字符串。通常是平台定义的值之一，比如 ACTION_SEND 或 ACTION_VIEW。
        使用 <action> 元素在您的 Intent 过滤器中指定此值。您在此元素中指定的值必须是操作的完整字符串名称，
        而不是 API 常量（请参阅以下示例）。
      - 数据
        与 Intent 关联的数据描述。
        用 <data> 元素在您的 Intent 过滤器中指定此内容。
        使用此元素中的一个或多个属性，您可以只指定 MIME 类型、URI 前缀、URI 架构
        或这些的组合以及其他指示所接受数据类型的项。 
        如果您无需声明关于数据的具体信息 Uri（比如，您的 Activity 处理其他类型的“额外”数据
        而不是 URI 时），您应只指定 android:mimeType 属性声明您的 Activity 处理的数据类型，
        比如 text/plain 或 image/jpeg。
      - 类别
        提供另外一种表征处理 Intent 的 Activity 的方法，通常与用户手势或 Activity 启动的位置有关。
        系统支持多种不同的类别，但大多数都很少使用。 但是，所有隐含 Intent 默认使用 
        CATEGORY_DEFAULT 进行定义。
        用 <category> 元素在您的 Intent 过滤器中指定此内容。
        
      #+BEGIN_SRC xml
      <!--此处有一个 Activity 与在数据类型为文本或图像时处理 ACTION_SEND-->
      <activity android:name="ShareActivity">
          <intent-filter>
              <action android:name="android.intent.action.SEND"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:mimeType="text/plain"/>
              <data android:mimeType="image/*"/>
          </intent-filter>
      </activity>

      <activity android:name="ShareActivity1">
          <!-- filter for sending text; accepts SENDTO action with sms URI schemes -->
          <intent-filter>
              <action android:name="android.intent.action.SENDTO"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:scheme="sms" />
              <data android:scheme="smsto" />
          </intent-filter>
          <!-- filter for sending text or images; accepts SEND action and text or image data -->
          <intent-filter>
              <action android:name="android.intent.action.SEND"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:mimeType="image/*"/>
              <data android:mimeType="text/plain"/>
          </intent-filter>
      </activity>
      #+END_SRC
      为了接收隐含 Intent，您必须在 Intent 过滤器中包含 CATEGORY_DEFAULT 类别。
      方法 startActivity() 和startActivityForResult() 将按照已声明 CATEGORY_DEFAULT 类别的方式
      处理所有 Intent。如果您不在 Intent 过滤器中声明它，则没有隐含 Intent 分解为您的 Activity。 

***** 处理您的 Activity 中的 Intent
      当您的 Activity 启动时，调用 getIntent() 检索启动 Activity 的 Intent。
      您可以在 Activity 生命周期的任何时间执行此操作，
      但您通常应在早期回调时（比如，onCreate() 或 onStart()）执行。 
      #+BEGIN_SRC java
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);

          setContentView(R.layout.main);

          // Get the intent that started this activity
          Intent intent = getIntent();
          Uri data = intent.getData();

          // Figure out what to do based on the intent type
          if (intent.getType().indexOf("image/") != -1) {
              // Handle intents with image data ...
          } else if (intent.getType().equals("text/plain")) {
              // Handle intents with text ...
          }
      }
      #+END_SRC
***** 返回结果
      只需调用 setResult() 指定结果代码和结果 Intent。
      当您的操作完成且用户应返回原始 Activity 时，调用 finish() 关闭（和销毁）您的 Activity。 
      默认情况下，结果设置为 RESULT_CANCELED。
      因此，如果用户在完成操作动作或设置结果之前按了返回按钮，原始 Activity 会收到“已取消”的结果。
      #+BEGIN_SRC java
      // Create intent to deliver some kind of result data
      Intent result = new Intent("com.example.RESULT_ACTION", Uri.parse("content://result_uri"));
      setResult(Activity.RESULT_OK, result);
      finish();
      // 如果您使用结果代码传递整数，且无需包括 Intent，则可调用 setResult() 且仅传递结果代码。
      setResult(RESULT_COLOR_RED);
      finish();
      #+END_SRC
      
** Android Studio
*** Meet Android Studio
**** Overview
     *Android Studio* is the official Integrated Development Environment(IDE)
     是官方集成开发环境
***** Project structure
      project -> modules(App/Library/Google App Engine)
                   + source code files
                   + resource files
****** Application
       - AndroidMainfest.xml
       - java
       - res
****** Gradle Scripts(构建脚本)
       
**** Install Android Studio
**** Migrate to Android Studio
**** Configure Android Studio
***** Find your configuration files
      Windows: %USERPROFILE%\.<CONFIGURATION_FOLDER>/
      Mac: ~/Library/Preferences/<CONFIGURATION_FOLDER>/
      Linux: ~/.<CONFIGURATION_FOLDER>/

      STUDIO_VM_OPTIONS: set the name and location of the .vmoptions file
      STUDIO_PROPERTIES: set the name and location of the .properties file
      STUDIO_JDK: set the JDK with which to run Studio
***** Customize your VM options
      Help > Edit Custom VM Options bin/
***** Maximum heap size
      Help > Edit Custom VM Options (studio.vmoptions) -Xmx2g
      jps -lvm
***** Export and import IDE settings(Settings.jar)
***** Customize your IDE properties(idea.properties)
***** Configure the IDE for low-memory machines
***** Set JDK version
      File > Project Struct > SDK Location > JDK location
***** Set proxy settings(build.gradle)

*** Workflow basics
    1. Set up your workspace, create a project
    2. Write your app
    3. Build and run
    4. Iterate (Debut/profile/Test)
    5. Publish
*** Manage your project
**** Overview
     *Project* source code, assets, test code, build configurations.
***** Modules
      *Modules* is a clllection of source files and build settings that allow
                you to divide you project into discrete units of functionality.
                代码、构建配置集合，将项目划分为功能单元模块。
      *App module* 应用程序模块
      *Library module* 库模块
                Android Library(contain all file types)
                Java Library(contain only Java source files)
      *Google Cloud module*
***** Project files
      
**** Create a project
**** Add C and C++ code
**** Create an Android library     
** ndk
*** Getting Started with the NDK(Native Development Kit)
   *NDK* is a set of tools that allows you to use C/C++ code with Android, and
   provides platform libraries.
   *JNI* Java Native Interface
   https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html
   *CMake/ndk-build* build tools;
**** Download the NDK and Tools
   *components* NDK,CMake,LLDB(debugger)
   Tool > Android > SDK Manager
**** Create or Import a Native Project
    
*** Concepts
    优点，重用代码、提高性能
**** How it Works
     - ndk-build
     - Android OS runs in the Dalvik Virtual Machine(DVM)
**** Flow
     1. java/C++业务逻辑分界
     2. Create an Android app
     3. if(native-only){declare the NativeActivity class}
     4. Create an Android.mk descirbing the native library
     5. Optionally, configing target ABIs,toolchain, release/debug mode ...
     6. Place you native source under the project's jni directory.
     7. Use ndk-build to compile ht native(.so, .a) libraries.
     8. Build the Java component, producing the executable .dex file.
     9. Package everything into an APK file, containing .so, .dex and others.


**** Native Activities and Applications
     *NativeActivities* allows your to write a completely native activity.
     - *native_activity.h*
     - *android_native_app_glue.h*
**** Using the native_activity.h interface
  
*** JNI Tips
**** Threads
     AttachCurrentThread/AsDaemon()
     ...
     DetachCurrentThread()
     exit
**** jclass, jmethodID, jfieldID
     FindClass();
     GetFieldID()
     GetIntField();
**** Local and Global References
     NewGlobalRef()/NewWeakGlobalRef()
     IsSameObject()

*** Building
**** CMake
***** Using CMake variables in Grandle
      module-level build.gradle
      android {
      ...
      defaultConfig {
      ...
      // This block is different from the one you use to link Gradle
      // to your CMake build script.
      externalNativeBuild {
      cmake {
      ...
      // Use the following syntax when passing arguments to variables:
      // arguments "-DVAR_NAME=ARGUMENT".
      arguments "-DANDROID_ARM_NEON=TRUE",
      // If you're passing multiple arguments to a variable, pass them together:
      // arguments "-DVAR_NAME=ARG_1 ARG_2"
      // The following line passes 'rtti' and 'exceptions' to 'ANDROID_CPP_FEATURES'.
      "-DANDROID_CPP_FEATURES=rtti exceptions"
      }
      }
      }

* android studio
  http://www.cnblogs.com/whycxb/category/1001652.html
** 代码混淆
修改 build.gradle -> buildTypes.release.minifyEnabled true

#==================================API=================================================
#API里边的类，最好都要避免混淆
-keep public class * extends android.app.Fragment
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class * extends android.support.v4.**
-keep public class com.android.vending.licensing.ILicensingService

-dontwarn android.annotation
-keepattributes *Annotation*

#=====================保留了所有的Native变量名及类名=====================
-keepclasseswithmembernames class * {
    native <methods>;
}
#某些构造方法不能去混淆
-keepclasseswithmembernames class * {
    public <init>(android.content.Context, android.util.AttributeSet);
}
#枚举类不能去混淆
-keepclasseswithmembernames class * {
    public <init>(android.content.Context, android.util.AttributeSet, int);
}

#aidl文件不能去混淆.
-keep class * implements android.os.Parcelable {
  public static final android.os.Parcelable$Creator *;
}

-keepclassmembers class * {
   public <init>(org.json.JSONObject);
}

#=====================不混淆资源类=====================
-keepclassmembers class **.R$* {
    public static <fields>;
}
#过滤R文件的混淆：
-keep class **.R$* {
    *;
}

#=================================当前项目==================================================
#一般model最好避免混淆（model无关紧要，不混淆也没多大关系）如：
#-keep class com.why.project.helloworld.bean.**{*;}

#===================================其他常规================================================
#加上这句话，不然会在控制台中报warning警告【不添加的话比较好，可以用来验证签名是否成功】
#-ignorewarnings
#设置混淆的压缩比率 0 ~ 7
-optimizationpasses 5
#Aa aA
-dontusemixedcaseclassnames
#混淆后生产映射文件 map 类名->转化后类名的映射
-verbose
#混淆采用的算法.
-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
* android develop
** 1. 项目组成
   - src ; 源码目录
   - AndroidMainfest.xml ; 清单文件，描述程序构成，组件，权限等配置
   - gen/R.java ;
   - assets ; 静态资产文件
   - drawable ; 图标
   - layout ; 布局
   - values ; string.xml
   - apk ; 安装包
** 2. 核心组件
   - View ; 界面视图，组织UI控件
   - Intent ; 意图，支持组件间通信
   - Activity ; 处理界面与UI交互
   - Content Provider ; 存储共享数据
   - IntentReceiver ; 接收消息及事件处理
   - Service ; 后台服务，硬件与启动
   - Notification ; 消息与通知
** 3. Activity(活动)
*** 概念
    - 最基本的应用程序组件
    - 一个单独的屏幕，显示响应事件，以及启动其它组件
    - android.app.Activity
*** 生命周期
    onCreate()/onStart()/onRestart()/onResume()/onPause()/onStop()/onDestroy()
    (Activity start)
    onCreate()            /---<----------------------------------------\
    onStart()  <-------------------------------------\                 |
    onResume() <-----------------------------------\ |                 |
    (Activity is-running)                          | |                 |
    <New Activity is-started)           (comes to the foreground)  (navigates back)
    onPause() -->----------------------------------/ |            (porcess is-killed)
    <Your Activity is no longer visible>             |                 |
    onStop() -->------------------------------------/                  |
                  \--------------------->------------------------------/
    onDestroy()
    (Activity is-shut down)
   
** 4. Intent(意图)
*** 概念
    - 减少组件耦合
    - 组件间传递Intent来执行动作和产生事件
    - 活动、服务、广播接收器
    - 显式 Intent.setComponent()/Intent.setClass()
    - 隐式 根据inter-filter中设置的action/category/URI/DataType 找到合适的组件处理
           android.intent.category.DEFAULT
*** Bundle(一捆)
    - 挟带数据 HashMap<String, Object>;
    - public final class Boundle implements Parcelable, Cloneable{HasnMap<String, Object> mMap; ...}
*** AndroidManifest.xml(清单)
    #+BEGIN_SRC xml
    <?xml version="1.0" encoding="utf-8"?>
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              package="com.tst.z.myapplication">        # 包名
      <application
          android:allowBackup="true"
          android:icon="@mipmap/ic_launcher"            # 应用程序图标
          android:label="@string/app_name"              # 调用values文件夹里的字符串数据
          android:roundIcon="@mipmap/ic_launcher_round" # 
          android:supportsRtl="true"
          android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">         # Activity      活动
          <intent-filter>                               # intent-filter 意图过滤器
            <action android:name="android.intent.action.MAIN" /> # 首先打开的运行页面
            
            <category android:name="android.intent.category.LAUNCHER" />
          </intent-filter>
        </activity>
      </application>
    </manifest>
    #+END_SRC
    R.java 定义各类资源ID
*** MainActivity(主活)
    #+BEGIN_SRC java
    package com.tst.z.myapplication;

    import android.support.v7.app.AppCompatActivity;
    import android.os.Bundle;
    import android.widget.TextView;

    public class MainActivity extends AppCompatActivity {

        // Used to load the 'native-lib' library on application startup.
        static {
            System.loadLibrary("native-lib");
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);           // 调用父类方法
            setContentView(R.layout.activity_main);       // 设置内容视图

            // Example of a call to a native method
            TextView tv = (TextView) findViewById(R.id.sample_text);
            tv.setText(stringFromJNI());
        }

        /**
         ,* A native method that is implemented by the 'native-lib' native library,
         ,* which is packaged with this application.
         ,*/
        public native String stringFromJNI();
    }
    #+END_SRC
*** main_activity.xml
    #+BEGIN_SRC xml
    <?xml version="1.0" encoding="utf-8"?>
    <android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".MainActivity">

        <TextView
            android:id="@+id/sample_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Hello World!"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

    </android.support.constraint.ConstraintLayout>
    #+END_SRC
** 5. UI事件处理与布局管理
*** View/ViewGroup
   - View 视图组件；占据一块矩形区域，负责渲染、处理时间、可见、焦点
     ViewGroup ; View容器，布局Views，可以添加进另一个ViewGroup
   - Layout 布局组件
   - Wigets UI元素
   - Menus 菜单
*** 事件处理
    onKeyDown()/onKeyUp()/onTouchEvent()
*** Toast(提醒消息)
    Toast.makeText(this, string, Toast.LENGTH_SHORT).show();
*** 布局
    - LinearLayout(线性布局) ; 一行或一列排列控件
    - AbsoluteLayout(绝对布局) ; 固定坐标
    - RelativeLayout(想对布局) ; addroid:layout_below/above/toRightOf/toLeftOf
    - TableLayout(表格布局) ; android:layout_weight/TableRow
    - FrameLayout(框架布局)

** 6. Service
   - 运行在后台的一段代码
   - 不是进程也不是线程
   - 不与用户交互/后台更新
*** 生命周期
    onCreate()
    onStart()
    onDestroy()
    onBind()
    onUnbind()
    public class MyService extends Service {...}
** 7. Notification(通知)
** 8. 文件操作
* poco
** Standalone Toolchain