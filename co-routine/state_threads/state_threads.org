* State Threads for Internet Applications
** Introduction简介
   an application library一个程序库
   writing fast and highly scalable Internet Applications快速写可伸缩互联网应用
** 1.Definitions定义
*** 1.Internet Applications互联网应用程序
    IA is either a server or client network application 
    IA是一个服务也是一个客户端网络应用
    that accepts connections form clients 接收客户端连接
    and may or may not connect to servers 连接或不连接到其他服务
    IA is a data-driven application IA是数据驱动应用程序
    For eache connection, an IA does some finite amount of work invoving data 
    exchange with its peer, where its peer may be either a client or a server.
    么个连接，IA做有限工作量包括数据交换，对端是个节点。
Web Server最典型的应用，接受一个连接，对请求数据进行有限的可测量的工作，然后应答
给对端。
proxy server(IA)代理服务，接受连接并连接其他服务器。
我们假设IA的性能受可用CPU周期而不是网络带宽或磁盘I / O（即CPU是瓶颈资源）的限制。
*** 2.Performance and Scalability 性能和可伸缩性
    IA的性能通常被评估为以每秒事务数或每秒字节数衡量的吞吐量。有几个基准可用于测
量特定工作负载的Web服务应用程序的吞吐量( SPECweb96, WebStone, WebBench)。
尽管可扩展性没有通用的定义，一般而言，它表示应用程序在外部条件发生变化时维持其性
能的能力。对于IAs，这个外部条件或者是客户的数量（也称为“用户”，“同时连接”或“负载
生成器”）或底层的硬件系统大小（CPU数量，内存大小等）。因此，有两种类型的可扩展性
负载可扩展性和系统可扩展性。
    下图显示理想化IA的吞吐量随客户端数量的增加而变化（蓝色实线）。最初吞吐量线性
增长（斜率代表一个客户可以提供的最大吞吐量）。在这个初始范围内，IA没有得到充分利
用，而且CPU部分闲置。客户数量的进一步增加导致系统饱和，随着所有CPU被充分利用，吞
吐量逐渐停止增长。在此之后，吞吐量保持平稳，因为没有更多的CPU周期可用。然而，在
现实世界中，即使闲置时，每个同时连接也消耗一些计算和存储资源，并且这种开销随着客
户端的数量而增长。因此，真实世界IA的吞吐量在某点之后开始下降（下图中的蓝色虚线）
吞吐量下降的速度取决于应用程序设计等。我们说如果一个应用程序可以在很宽的负载范围
内维持其吞吐量，那么这个应用程序就具有良好的可扩展性。有趣的是，SPECweb99基准测
试在某种程度上反映了Web服务器的负载可扩展性，因为它测量了每个客户端强制性最小吞
吐量（即测量服务器容量）的客户端数量（负载生成器）。这与SPECweb96和其他使用吞吐
量作为其主要指标的基准不同（参见下图）。
    系统可伸缩性是指应用程序能够在每个硬件单元（如CPU）上保持其性能，同时这些单
元的数量也在不断增加。换句话说，良好的系统可扩展性意味着处理器数量增加一倍将大致
使应用程序吞吐量翻倍（绿色虚线）。我们在这里假设底层操作系统也可以很好地扩展。
良好的系统可扩展性使您可以在最小的系统上运行应用程序，同时保留将应用程序迁移到更
大的系统（如果有必要）的能力，而无需过多的工作或费用。也就是说，在更改系统大小时
，不需要重新编写应用程序，甚至不需要重大移植工作。虽然可伸缩性和性能在服务器IAs
的情况下更为重要，但对于某些客户端应用程序（例如基准负载生成器）也应该考虑它们。
*** 3.Concurrency 并发
    并发性反映了系统中的并行性。两个不相关的类型是虚拟并发和实际并发。
- 虚拟（或明显）并发是系统支持的同时连接的数量。
- 真正的并发性是硬件设备（包括CPU，网卡和磁盘）的数量，它们实际上允许系统并行执
  行任务。
IA必须提供虚拟并发性，以便同时为多个用户提供服务。为了达到最大的性能和可扩展性，
OS内核创建的编程实体数量要比系统内核的实际并发数量要接近（在一个数量级以内）。
这些由内核调度的编程实体被称为内核执行工具。内核执行工具的例子包括Solaris轻量级
进程和IRIX内核线程。换句话说，内核执行任务的数量应该取决于系统的规模，而不是同时
连接的数量。
** 2.Existing Architectures 现有体系结构
   有几种不同的体系结构是IAs常用的。这些包括多进程，多线程和事件驱动的状态机体系
结构。
*** 1.Multi-Process Architecture 多进程架构
    在多进程（MP）体系结构中，每个进程专用于每个同时(正交)连接。一个进程完成一个
事务的所有初始化步骤并为一个连接提供服务，然后继续为新的连接提供服务。IAs 的用户
会话相对独立;处理不同连接的进程之间不需要同步。因为每个进程都有自己的私有地址空
间，所以这个架构非常健壮。如果服务其中一个连接的进程崩溃，则其他会话将不受影响。
但是，为了服务许多并发连接，必须采用相同数量的进程。因为进程是内核实体（实际上是
最重的），所以内核实体的数量至少与并发会话的数量一样大。在大多数系统中，当由于高
的上下文切换开销而创建超过几百个进程时，不能实现良好的性能。 换句话说，MP应用程
序的负载可伸缩性较差。另一方面，MP应用程序具有非常好的系统可扩展性，因为没有资源
在不同进程之间共享，并且没有同步开销。
Apache Web Server 1.x（[参考1]）在UNIX系统上使用MP体系结构。
*** 2.Multi-Threaded Architecture 多线程体系结构
    在多线程（MT）架构中，每个线程有独立的线程堆栈。就像MP体系结构中的一个进程一
样，每个线程都会执行所有事务的初始化步骤，并在继续为新的连接提供服务之前完成对连
接的服务。许多现代UNIX操作系统在将用户级线程映射到内核实体时实现了多对多模型。
在这个模型中，任意数量的用户级线程被复用到较少的内核执行单元上。内核执行载体也被
称为虚拟处理器。每当用户级线程进行阻塞系统调用时，它正在使用的内核执行单元将在内
核中被阻塞。如果没有其他非阻塞的内核执行单元，并且还有其他可运行的用户级线程，则
会自动创建一个新的内核执行单元。这可以防止应用程序在继续进行有用的前进时阻塞。
    因为IAs本质上是网络I / O驱动的，所有的并发会话在不同的点上阻塞在网络I/O上。
因此，内核中创建的虚拟处理器的数量增长接近用户级线程（或同时连接）的数量。发生这
种情况时，多对多模型退化为一对一模型。同样，像在MP架构中一样，内核执行单元的数量
是由同时连接的数量决定的，而不是由CPU的数量决定的。这减少了应用程序的负载可伸缩
性。但是，由于内核线程（轻量级进程）比传统的UNIX进程使用更少的资源并且更轻量级，
因此与MP应用程序相比，MT应用程序的负载应该更好地扩展。不料，在MT架构中共享相同地
址空间的少量虚拟处理器破坏了应用程序的系统可伸缩性，因为各种锁上的线程之间存在争
用。即使应用程序本身经过精心优化以避免锁定其自身全局数据（非平凡任务）的争用，仍
然存在标准库函数和系统调用，这些函数和系统调用使用公共资源隐藏在应用程序中。
例如，在许多平台上，内存分配例程（malloc（3），free（3）等）的线程安全性是通过使
用单个全局锁来实现的。另一个例子是每个进程的文件描述符表。这个公共资源表由同一进
程内的所有内核执行单元共享，并且在通过某些系统调用（如open（2），close（2）等）
进行修改时必须受到保护。除此之外，在多处理器系统中的CPU之间保持高速缓存一致性会影
响在不同CPU上运行的不同线程修改同一高速缓存线上的数据项时的性能。
为了提高负载可扩展性，一些应用采用了不同类型的MT架构：他们为每个任务创建一个或多
个线程，而不是每个连接一个线程。例如，一小组线程可能负责接受客户端连接，另一个线
程负责请求处理，另一个负责服务响应。这种架构的主要优点是消除了线程数和同时连接数
之间的紧密耦合。但是，在这种体系结构中，不同的特定于任务的线程组必须共享必须受互
斥锁保护的共同工作队列（典型的生产者 - 消费者问题）。这增加了同步开销，导致应用
程序在多处理器系统上执行不良。换句话说，在这种体系结构中，为了负载可扩展性，牺牲
了应用程序的系统可伸缩性。当然，线程编程的噩梦（包括数据损坏，死锁和竞态条件）也
使MT架构编写非常复杂。

*** 3.Event-Driven State Machine Architecture 事件驱动的状态机架构
    在事件驱动状态机（EDSM）架构中，采用单个进程来同时处理多个连接。Comer和Steve
ns[参考文献2]描述了这种架构的基础知识。EDSM架构一次执行与特定连接关联的一个基本
的数据驱动的步骤，因此复用了许多并发的连接。这个过程作为一个状态机来运行，它接收
一个事件，然后作出反应。
在空闲状态下，EDSM调用select（2）或poll（2）来等待网络I / O事件。当一个特定的文件
描述符准备好I / O时，EDSM完成相应的基本步骤（通常通过调用处理函数）并启动下一个。
此架构使用非阻塞系统调用来执行异步网络I / O操作。有关非阻塞I / O的更多详细信息，
请参阅Stevens [参考文献3]。为了利用硬件并行（真正的并发），可以创建多个相同的进程。
这被称为对称多进程EDSM并被使用，例如在Zeus Web Server中（[参考文献4]）。为了更有效
地复用磁盘I / O，可以创建特殊的“辅助”进程。这被称为非对称多进程EDSM，并被Druschel
等人提出用于Web服务器[参考文献5]。
*EDSM可能是IAs最具扩展性的架构。* 由于同时连接（虚拟并发）的数量与内核执行单元（
进程）的数量完全分离，这个架构有非常好的负载可扩展性。它只需要最小的用户级资源来创
建和维护额外的连接。与MP应用程序类似，多进程EDSM具有非常好的系统可扩展性，因为没有
资源在不同进程之间共享，并且没有同步开销。
不幸的是，EDSM架构是单一的，而不是基于线程的概念，所以通常需要从头开始实施新的应用
。实际上，EDSM架构很难模拟线程和堆栈。
** 3.State Threads Library 状态线程库
   State Threads库结合了上述所有体系结构的优点。该接口保留了线程抽象的编程简单性
，允许在单个进程中将每个同时连接视为一个单独的执行线程。底层实现接近EDSM架构，因
为每个特定的并发会话的状态保存在单独的内存段中。
*** 1.State Changes and Scheduling 状态变化和调度
    每个并发会话的状态包括其堆栈环境（堆栈指针，程序计数器，CPU寄存器）及其堆栈.
从概念上讲，线程上下文切换可以被看作是一个改变其状态的进程。除了进程之外，没有涉
及到的内核实体。与其他通用线程库不同，状态线程库是完全确定性的。线程上下文切换（
进程状态更改）只能发生在众所周知的一组函数中（在I / O点或显式同步点上）。因此，
在大多数情况下，特定于进程的全局数据不必受互斥锁保护。整个应用程序可以自由使用所
需的所有静态变量和非重入库函数，大大简化了编程和调试，同时提高了性能。这有点类似
于一个协同例程模型（合作的多任务线程），除了不需要显式的yield(让出时间片) - 一个
线程迟早会执行一个阻塞的I / O操作，从而放弃控制。所有的执行线程（同时连接）具有
相同的优先级，所以调度是非抢先的，就像在EDSM架构中一样。因为IAs是数据驱动的（处
理受到网络缓冲区大小和数据到达率的限制），所以调度是非时间切片的。只有两种类型的
外部事件由库调度器处理，因为只有select（2）或poll（2）才能检测到这些事件：
I / O事件（文件描述符已准备好进行I / O）和时间事件（某些超时已经过期）。
但是，其他类型的事件（例如发送到进程的信号）也可以通过将其转换为I / O事件来处理。
例如，信号处理函数可以执行对管道的写操作（write（2）是可重入/异步安全的），从而
将信号事件转换为I / O事件。为了利用EDSM架构中的硬件并行性，可以以对称或非对称的
方式创建多个进程。流程管理不在库的范围内，而是留给应用程序。
有几个通用线程库实现了多对一的模型（许多用户级线程到一个内核执行工具），使用与“
状态线程”库相同的基本技巧（非阻塞I / O，事件驱动调度器等）。有关示例，请参阅GNU
可移植线程（[参考6]）。因为它们是通用的，所以这些库与State Threads库有不同的目标。
状态线程库不是一个通用的线程库，而是一个只针对特定类型的应用程序（IA）的应用程序
库，以便为这些应用程序实现最高的性能和可伸缩性。
*** 2.可扩展性
    状态线程是非常轻量级的用户级实体，因此创建和维护用户连接所需的资源极少。随着
连接数量的增加，使用状态线程库的应用程序可以很好地扩展。
在多处理器系统上，应用程序应该创建多个进程来利用硬件并行性。使用多个单独的进程是
实现最高系统可扩展性的唯一方法。这是因为复制每个进程资源是避免多处理器系统上的显
着同步开销的唯一方法。创建单独的UNIX进程自然会提供资源重复。同样，与EDSM架构一样
，同时连接的数量（可能非常大，在很大的范围内变化）和内核实体的数量（通常很小且不
变）之间没有联系。换句话说，状态线程库使得将大量的同时连接复用到更少数量的单独进
程成为可能，从而允许应用程序在负载和系统大小两方面都可以很好地扩展。
*** 3.Performance 性能
    性能是库的主要目标之一。状态线程库被实现为尽量减少系统调用的次数，并尽可能快
地创建线程和上下文切换。例如，per-thread信号掩码不存在（与POSIX线程不同），因此
不需要在每个线程上下文切换上保存和恢复进程的信号掩码。这消除了每个上下文切换的两
个系统调用。将信号事件转换为I / O事件可以更有效地处理信号事件（见上文）。
*** 4.Portablity 可移植性
    该库使用与EDSM体系结构相同的基本概念，包括非阻塞I / O，文件描述符和I / O复用
在大多数UNIX平台上，这些概念都是以某种形式提供的，这使得该库可以在许多UNIX平台上
移植。源代码中只有少数依赖于平台的部分。
** 4. 状态线程和NSPR
   状态线程库是Netscape可移植运行时库（NSPR）的一个衍生物[参考文献7]。NSPR的主要
目标是为系统设施提供平台无关的层，系统设施包括线程，线程同步和I / O。性能和可扩
展性不是NSPR的主要关注点。状态线程库解决了性能和可伸缩性问题，同时仍然比NSPR小得
多。它包含在8个源文件中，而不是400多个，但提供了在类UNIX平台上编写高效IAs所需的
所有功能。
|------------+--------+---------------|
| item       |   NSPR | State Threads |
|------------+--------+---------------|
| 代码(line) | 150000 |          3000 |
| lib(KB)    |    700 |            60 |
|------------+--------+---------------|
** 5.Conclusion 结论
    状态线程是为编写Internet应用程序提供基础的应用程序库。总而言之，它具有以下优
点：
- 它允许设计快速和高度可扩展的应用程序。 一个应用程序可以很好的负载(load)和系统
  (CPUs)扩展。
- 它大大简化了应用程序编程和调试，因为通常不需要互斥锁定，整个应用程序可以自由使
  用静态变量和不可重入库函数。
库的主要限制：
所有对套接字的I/O操作都必须使用状态线程库的I/O函数，因为只有这些函数执行线程调度
并阻止应用程序的进程阻塞。
* Stat Threads Library Reference(参考手册)
** Types(类型)
状态线程库在 *st.h* 头文件中定义了以下类型：
- *st_thread_t*
  Thread type. 线程类型
  *Syntax(语法)*
  typedef void *  st_thread_t;
  *Description(描述)*
  线程由一个指向不透明数据结构的指针表示和标识。这个指针是大多数在线程上运行的函
  数的必需参数。
  线程标识符保持有效，直到线程从其(root function)根函数返回，并且如果线程被创建
  为可(join)连接的，则被(join)连接。
- *st_cond_t*
  条件变量类型。
  *Syntax(语法)*
  typedef void *  st_cond_t;
  *Description(描述)*
  条件变量是由指针标识的不透明对象。条件变量提供同步原语来等待或唤醒等待某些条件
  的线程得到满足。
  在状态线程库中，在等待条件变量之前不需要锁定互斥体。
- *st_mutex_t*
  互斥锁
  *Syntax(语法)*
  typedef void *  st_mutex_t;
  *Description(描述)*
  互斥体是由指针标识的不透明对象。 互斥锁（互斥锁）用于通过代码的关键部分将线程
  的执行序列化。
  如果使用状态线程库的应用程序在没有I/O的情况下写入，或者在关键部分产生控制权（
  在关键部分中没有阻塞功能），则不需要互斥体。
  这些互斥锁只能用于进程内线程同步。 它们不能用于进程间同步。
- *st_utime_t*
  高分辨率时间类型（“u”代表“微妙”）。
  *Syntax(语法)*
  typedef unsigned long long  st_utime_t;
  *Description(描述)*
  这种数据类型（无符号的64位整数）表示自从过去的任意时间以来以微秒表示的高分辨率
  实时。 这与任何时间都不相关。
- *st_netfd_t*
  文件描述符类型。
  *Syntax(语法)*
  typedef void *  st_netfd_t;
  *Description(描述)*
  此数据类型通常代表网络通信的任何开放式端点（套接字，管道端点，FIFO等），但可封
  装任何打开的文件描述符。 这种类型的对象由一个指向不透明数据结构的指针来标识。
- *st_switch_cb_t*
  上下文切换回调函数类型。
  *Syntax(语法)*
  typedef void (*st_switch_cb_t)(void);
  *Description(描述)*
  这个数据类型是一种便利的类型，用于描述一个函数的指针，当一个线程被设置为停止或
  者设置为运行时，这个函数将被调用。 只有在<st.h>中定义了ST_SWITCH_CB时，此功能
  才可用。
** Error Handling(错误处理)
- 成功 >=0 | !NULL
  所有状态线程库非void函数成功返回一个非负整数或指向新创建的对象（构造函数类型的函
  数）的指针。
- 失败 -1 | NULL
  它们分别返回-1或一个NULL指针，并设置全局错误号errno来表示错误。使用errno
  是安全的，因为它是在函数返回之前设置的，一次只有一个线程可以修改它的值。
perror（3）函数可用于在标准错误输出上产生错误消息。
** Library Initialization(初始化)
- *st_init()*
  Initializes the runtime.
  *Syntax*
  int st_init(void);
  *Parameters*
  None.
  *Returns*
  成功完成后，返回值为0。 否则，将返回-1的值，并将errno设置为指示错误。
  *Description*
  该函数初始化库运行时。 在调用任何其他状态线程库函数之前，应该在应用程序main()
  函数的开头附近调用它。
  除此之外，此函数将开放文件描述符的数量限制为每个进程施加的最大操作系统数，或者
  ，如果使用select（2），则将FD_SETSIZE中的较小值（getrlimit（2））限制为最大值。
  这个限制可以通过st_getfdlimit（）来获取。 它还将SIGPIPE信号的配置设置为SIG_IGN
  （将被忽略）（信号（5））。
  与POSIX线程不同，由fork（2）系统调用创建的新进程是调用进程的精确副本，并且在父
  进程中运行的所有状态线程都存在于子进程中。
  这意味着可以在fork（2）创建多个进程之前或之后调用st_init()。如果库运行时未正确
  初始化（例如，st_init（）被意外省略），那么该进程将分别在新线程创建或第一个上下
  文切换时收到算术异常（SIGFPE或SIGTRAP）或分段错误（SIGSEGV）信号。
- *st_getfdlimit()*
  返回调用进程可以打开的文件描述符的最大数量。
  *Syntax*
  int st_getfdlimit(void);
  *Parameters*
  None.
  *Returns*
  调用进程可以打开的最大文件描述符数量。 如果在通过st_init（）成功初始化库之前调
  用此函数，则返回值-1。
  *Description*
  该函数返回由st_init（）函数设置的打开文件描述符的数量限制。
- *st_set_eventsys()*
  设置事件通知机制。
  *Syntax*
  int st_set_eventsys(int eventsys);
  *Parameters*
  eventsys 标识选定事件通知机制。 以下值在st.h头文件中定义：
  - *ST_EVENTSYS_DEFAULT*
    使用默认的事件通知机制。通常它是select（2），但是如果该库是使用定义的
    USE_POLL宏编译的，那么缺省值是poll（2）。
  - *ST_EVENTSYS_SELECT* 使用select
  - *ST_EVENTSYS_POLL* 使用poll
  - *ST_EVENTSYS_ALT* 使用替代事件通知机制。实际选择的机制取决于操作系统支持。
    例如，如果在Linux上支持epoll（4），将在FreeBSD / OpenBSD上使用kqueue（2）。
    如果操作系统不支持备用事件通知机制，则设置ST_EVENTSYS_ALT无效，并使用
    ST_EVENTSYS_DEFAULT机制。
  *Returns*
  成功完成后，返回值为0。 否则，将返回-1的值，并将errno设置为指示错误：
  - *EINVAL* 提供的eventsys参数具有无效值。
  - *EBUSY* 事件通知机制已经设置好了。
  *Description*
  此函数设置将由状态线程库使用的事件通知机制。要产生任何效果，必须在执行实际初始
  化的st_init（）函数之前调用它。 如果未调用st_set_eventsys（），则st_init（）将
  设置ST_EVENTSYS_DEFAULT机制。 机制一旦设置就不能改变。
  没有严格的选择事件通知机制的规则。 “最好的”取决于你的应用程序的行为。 尝试一下
  ，看看哪一个最适合你。
  作为一个经验法则，如果您的应用程序处理大量的网络连接（其中只有少数网络连接同时
  处于活动状态），则应该使用ST_EVENTSYS_ALT机制。
- *st_get_eventsys()*
  返回标识State Threads库正在使用的事件通知机制的整数值。
  *Syntax*
  int st_get_eventsys(void);
  *Parameters*
  None.
  *Returns*
  标识当前事件通知机制的整数值。 该值可以是以下值之一（请参见st_set_eventsys（））：
  ST_EVENTSYS_SELECT，ST_EVENTSYS_POLL或ST_EVENTSYS_ALT。 
  该库的未来版本可能会返回其他值。 如果尚未设置机制，则返回值-1。
  *Description*
  此函数返回标识State Threads库实际使用的事件通知机制的整数值。
- *st_get_eventsys_name()*
  返回状态线程库正在使用的事件通知机制的名称。
  *Syntax*
  const char *st_get_eventsys_name(void);
  *Parameters*
  None.
  *Returns*
  标识当前事件通知机制的字符串。 如果尚未设置机制（请参阅st_set_eventsys（）），
  则返回空字符串。 可能的返回值是“select”，“poll”，“kqueue”或“epoll”。 
  该库的未来版本可能会返回其他值。
  *Description*
  该函数返回标识State Threads库实际使用的事件通知机制的字符串。
- *st_set_switch_in/out_cb()*
  设置线程开关的可选回调函数。
  *Syntax*
  st_switch_cb_t st_set_switch_in_cb(st_switch_cb_t cb);
  st_switch_cb_t st_set_switch_out_cb(st_switch_cb_t cb);
  *Parameters*
  线程分别恢复和停止时调用的函数。
  *Returns*
  前面的回调函数指针
  *Description*
  这些函数分别设置线程恢复和停止时的回调。
  被调用后，任何线程切换都会调用回调。 使用NULL指针禁用回调（这是默认值）
  使用st_thread_self（）或线程特定的数据来区分线程。
  这些功能可以随时调用。
  只有在<st.h>中定义了 *ST_SWITCH_CB* 时，此功能才可用。
** Thread Control and Identification(线程控制和标识)
   这些函数对st_thread_t类型的线程对象进行操作。
- *st_thread_create()*
  创建一个新的线程。
  *Syntax*
  st_thread_t st_thread_create(void *(*start)(void *arg), void *arg,
                               int joinable, int stack_size);
  *Parameters*
  - *start*
    一个指向线程启动函数的指针，它被称为新线程的根。 从这个函数返回终止一个线程
  - *arg*
    指向根函数唯一参数的指针。
  - *joinable*
    指定线程是可连接的还是不可连接的。 如果此参数为零，则线程不可连接。 
    否则，它是可以连接的。 另请参见st_thread_join（）。
  - *stack_size*
    指定您对与新创建的线程关联的堆栈大小（以字节为单位）。
    如果您在此参数中传递零，将使用默认堆栈大小。
    IA-64上的默认堆栈大小是128 KB，而其他所有平台上的默认堆栈大小是64 KB。
    在IA-64上，只有一半的stack_size字节用于内存堆栈。 另一半用于寄存器堆栈后台存储。
  *Returns*
  成功完成后，将返回一个新的线程标识符
 （该标识符在线程从其启动函数返回之前保持有效）。 
  否则，返回NULL并将errno设置为指示错误。
  *Description*
  这个函数创建一个新的线程。 请注意，应用程序创建的线程总数受限于可用的交换空间
  量。 在创建线程时，stack_size字节在交换空间上保留。
  堆栈页面实际上并没有被使用（有效），直到被应用程序触摸。
- *st_thread_exit()*
  终止调用线程。
  *Syntax*
  void st_thread_exit(void *retval);
  *Parameters*
  - *retval*
    如果线程是可连接的，则可以通过st_thread_join（）来检索值retval。
    如果一个线程从它的start函数返回，就好像它已经用retval调用了
    st_thread_exit（）作为返回的值。
  *Returns*
  Nothing.
  *Description*
  这个函数终止调用线程。当线程退出时，通过为与活动键相关的任何非NULL线程指定的值
  调用析构函数（见st_key_create（）），就可以销毁每个线程的私有数据。
  当一个线程从它的启动函数返回时，这个函数被隐式地调用。
  *当最后一个线程终止时，进程以零状态值退出。*
- *st_thread_join()*
  阻塞调用线程，直到指定的线程终止。
  *Syntax*
  int st_thread_join(st_thread_t thread, void **retvalp);
  *Parameters*
  - *thread*
    要等待的线程的有效标识符。
  - *retvalp*
    如果这个参数不是NULL，那么线程的出口值将被放置在这个参数引用的位置
   （参见st_thread_exit（））。
  *Returns*
  成功完成后，返回值为0。 否则，将返回-1的值，并将errno设置为指示错误：
  - *EINVAL* 
    1. Target thread is unjoinable.
    2. Other thread already waits on the same joinable thread.
  - *EDEADLK* 
    Target thread is the same as the calling thread.
  - *EINTR*
    Current thread was-interrupted by st_thread_interrupt().
  *Description*
  此函数用于同步线程的终止，并可能检索其退出值。
  多个线程不能等待同一个线程完成 - 其中一个调用线程操作成功，其他线程则以错误结束。
  如果目标线程已经终止，则调用线程不会被阻塞。
- *st_thread_self()*
  标识调用线程。
  *Syntax*
  st_thread_t st_thread_self(void);
  *Parameters*
  None
  *Returns*
  总是返回对调用线程的有效引用 - 一个自我标识。
  *Description*
  这个函数标识调用线程。 这是创建线程从st_thread_create（）获得的相同标识符。
- *st_thread_interrupt()*
  中断一个目标线程。
  *Syntax*
  void st_thread_interrupt(st_thread_t thread);
  *Parameters*
  - *thread* A valid identifier for the thread being interrupted.
  *Returns*
  Nothing
  *Description*
  该函数中断（取消阻塞）阻塞在其中一个阻塞函数中的目标线程。
  被中断的函数返回一个错误，并将errno设置为EINTR。
  由目标线程决定是否执行中断（例如，它可能退出或仅仅中止当前事务）。

  注意：状态线程库函数不会被捕获的信号中断。
  阻塞库函数只有在当前线程通过st_thread_interrupt（）中断时才返回一个错误，
  并将errno设置为EINTR。

  如果一个目标线程已经可以运行或正在运行（例如，它是一个新创建的线程或者调用线程
  本身），这个函数将阻止它的后续阻塞。换句话说，只有当目标线程即将被阻塞时，
  中断才会被“传递”。
- *st_seleep()/st_usleep()*
  暂停当前线程一段指定的时间。
  *Syntax*
  int st_sleep(int secs);
  int st_usleep(st_utime_t usecs);
  *Parameters*
  - secs
    The number of seconds you want the thread to sleep for.
  - usecs
    The number of microseconds you want the thread to sleep for. 
    This parameter is a variable of type st_utime_t.
  *Returns*
  成功完成后，返回值为0。 否则，将返回-1的值，并将errno设置为指示错误：
  - EINTR The current thread was-interrupted by st_thread_interrupt().
  *Description*
  这些函数暂停调用线程执行指定的秒数（st_sleep（））或微秒（st_usleep（））。
  如果将零作为参数传递给st_sleep（），或者将ST_UTIME_NO_WAIT（0）
  传递给st_usleep（），则调用线程将让出执行，从而可能允许另一个线程运行。
  如果将-1作为参数传递给st_sleep（），或将ST_UTIME_NO_TIMEOUT（-1）
  传递给st_usleep（），则调用线程将永久挂起。 
  它可以通过st_thread_interrupt（）中断来重新启动。
- *st_randomize_stacks()*
  打开或关闭堆栈基址地址随机化。
  *Syntax*
  int st_randomize_stacks(int on);
  *Parameters*
  - *on*
    如果此参数具有非零值，则状态线程库会随机化分配给此调用后创建的线程的堆栈的
    基本地址。 否则，新线程的堆栈通常是页面对齐的。
  *Return*
  之前的堆栈随机化状态（如果关闭，则值为0，否则为非零值）。
  *Descriptoin*
  随机状态线程的堆栈基础可能会改善某些系统上的高速缓存性能，
  因为大量的状态线程都执行大致相同的工作，就像它们都从同一个根函数开始一样。
  在许多现代系统中，性能增加可以忽略不计。
  你应该比较你的应用程序的性能与这个功能开启和关闭，看看你是否真的需要它。
  当启用随机化时，新的堆栈被分配一页以容纳随机化。
  这个调用只影响之后创建的线程。 它对现有的线程没有影响。
** Per_thread Private Data(线程私有数据)
   这些函数允许将私有数据与进程中的每个线程相关联。
- **
** Synchronization(同步)
** Timing(时钟)
** I/O Functions(I/O函数)
** Program Structure(程序结构)
** List of Blocking Functions(阻塞(内部发生调度)函数表)
