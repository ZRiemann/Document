#+TITLE: Unix Network Programming V1
#+DESCRIPTION: Unix 网络编程
#+LANGUAGE: cn

* (一) 简介和TCP/IP

** 1. 简介
- 1.1 概述
  #+BEGIN_SRC ditaa
  +-----------+    +-----------+       +-----------+
  | client    |    | client    |...    | client    |
  +-----+-----+    +-----+-----+       +------+----+
        |                |                    |
        +----------------+--------------------+
                         |
                         |
                    +----+-------+
                    |  Server    |
                    +------------+
          一个服务器同时处理多个客户请求


   +-----------+    应用协议         +-----------+
   | WebClient | <-----------------> | WebClient |
   +-----------+                     +------+----+
        |                                   |             用户空间
  ------+-----------------------------------+-----------------------
   +------------+                    +------+-----+       内核空间
   |   TCP      | <----------------> |   TCP      |
   +------------+                    +------------+
        |                                   |
        |                                   |
   +------------+                    +------+-----+
   |   IP       |<------------------>|   IP       |
   +------------+                    +------+-----+
        |                                   |
   +----+-------+                    +------+-----+
   |  LINK      |<------------------>|  LINK      |
   +----+-------+                    +------------+
        |                                    |
        |                                    |
        |                                    |
   -----+----+----   ..............    --+---+------------
     LAN     |        WAN                | LAN
             |       +------------+      |
             +-------|  Routers   +------+
                     +------------+
  #+END_SRC
- 1.2 一个简单的时间获取客户程序
  #+BEGIN_SRC c
  # include "unp.h"

  int main(int argc, char **argv){
      int sockfd, n;
      char recvline[MAXLINE + 1];
      struct sockaddr_in servaddr;

      if(argc != 2){
          err_quit("usage: a.out <IPaddress>");
      }

      if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
          sys_err("socket error");
      }

      bzero(&servaddr, sizeof(servaddr));
      servaddr.sin_family = AF_INET;
      servaddr.sin_port = htons(13); /* daytime server */
      if(inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0){
          err_quit("inet_pton error for %s", argv[1]);
      }

      if(connect(sockfd, (SA*)&servaddr, sizeof(servaddr)) < 0){
          err_sys("connect error");
      }

      while((n = read(sockfd, recvline, MAXLINE)) > 0){
          recvline[n] = 0; /* null terminate */
          if(fputs(recvline, stdout) == EOF){
              err_sys("fputs error");
          }
      }
      if(n < 0){
          err_sys("read error");
      }

      exit(0);
  }
  #+END_SRC
- 1.9 拓扑发现
  - netstat
    #+BEGIN_SRC sh
    # 列出接口信息
    netstat -ni
    :<<!
    Kernel Interface table
    Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
    br-16243  1500        0      0      0 0             0      0      0      0 BMU
    br-25a62  1500        0      0      0 0             0      0      0      0 BMU
    br-4cd03  1500        0      0      0 0             0      0      0      0 BMU
    br-e44f8  1500        0      0      0 0             0      0      0      0 BMU
    docker0   1500        0      0      0 0             0      0      0      0 BMU
    docker_g  1500        0      0      0 0             0      0      0      0 BMU
    enp1s0    1500    63396      0      0 0         27925      0      0      0 BMRU
    lo       65536   144451      0      0 0        144451      0      0      0 LRU
    lxcbr0    1500        0      0      0 0             0      0      0      0 BMU
    lxdbr0    1500       70      0      0 0           408      0      0      0 BMRU
    vethMD4V  1500       70      0      0 0           431      0      0      0 BMRU
    !
    # 展示路由表
    netstat -nr
    :<<!
    Kernel IP routing table
    Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
    0.0.0.0         192.168.10.254  0.0.0.0         UG        0 0          0 enp1s0
    10.0.3.0        0.0.0.0         255.255.255.0   U         0 0          0 lxcbr0
    10.50.81.0      0.0.0.0         255.255.255.0   U         0 0          0 lxdbr0
    169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 enp1s0
    172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 docker0
    172.18.0.0      0.0.0.0         255.255.0.0     U         0 0          0 br-25a62b442ba1
    172.19.0.0      0.0.0.0         255.255.0.0     U         0 0          0 br-4cd03d6c00cd
    172.21.0.0      0.0.0.0         255.255.0.0     U         0 0          0 br-16243a37f49d
    172.22.0.0      0.0.0.0         255.255.0.0     U         0 0          0 br-e44f833411f1
    172.23.0.0      0.0.0.0         255.255.0.0     U         0 0          0 docker_gwbridge
    192.168.10.0    0.0.0.0         255.255.255.0   U         0 0          0 enp1s0
    !
    #+END_SRC
  - ifconfig
    #+BEGIN_SRC sh
    ifconfig enp1s0
    :<<!
    enp1s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
            inet 192.168.10.90  netmask 255.255.255.0  broadcast 192.168.10.255
            inet6 fe80::c7c7:9a94:f3c7:cee3  prefixlen 64  scopeid 0x20<link>
            ether 30:9c:23:46:81:93  txqueuelen 1000  (Ethernet)
            RX packets 65931  bytes 28683331 (28.6 MB)
            RX errors 0  dropped 0  overruns 0  frame 0
            TX packets 28607  bytes 5581490 (5.5 MB)
            TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
    !
    #+END_SRC
** 2. 传输层
*** TCP(Transmission Control Protocol)
- RFC768
*** UDP(User Datagram Protocol)
- RFC1323
- TCP选项
  - MSS(Maximum sigment size)
    - TCP_MAXSEG
  - 窗口规模
    - SO_RCVBUF
    - description
      随SYN发送，对端SYN有该选项，即可生效
  - 时间戳(不考虑)
*** SCTP(Stream Control Transmisstion Protocol)
*** 2.10 TCP端口号与并发服务器
    必须通过套接字对的4个元素来确定到达分节
    server(12.106.32.254, 192.168.42.1)(*:21, *:*)
    fork1{12.106.32.254:21, 206.168.112.210:1500}
    fork2{12.106.32.254:21, 206.168.112.219:1501}
*** 2.11 缓冲区大小限制
    - IPv4 16bit = 65535
    - IPv6 16bit+40 = 65575
      jumbo payload(特大净荷) 内部连接设计的，如HIPPI
    - MTU ether = 1500; SLIP=1006/296
      Mix = 68 = 20+40+8
      package > MTU 则IPv4/IPv6对包进行分片
    - IPv4.DF(don't fragment)
      package > MTU => ICMPv4 destination unreatchable, fragmentation needed but DF bit set
      IPv6 => ICMPv6: packet too big
      用于MTU发现，但是当今防火墙会抛弃ICMP！
    - minimum reassembly buffer size(最小重组缓冲区)
    - MSS(maximum segment size)
      随SYN发送，
**** 2.11.1 TCP输出
     - SO_SNDBUF 发送缓冲区
     - 阻塞套接字
       write 只是将用户缓冲区数据复制到内核的发送缓冲区；
       TCP 对缓冲区数据进行分节发送（MSS）
**** 2.11.2 UDP输出
     - SO_SNDBUF 标记最大数据报，不存在缓冲区，因为不需要ACK，所以不需要缓冲区
     - 当进程写一个大于套接字发送缓冲区大小的数据报是产生EMSGSIZE
       IP层进行分组，
     - ENOBUFS 表示内核空间不足， *有些实现不返回该错误！*
*** 2.12 标准因特网服务(telnet <host> <inet-server>)
    /etc/services
    | 名字    | TCP | UDP | RFC | desc |
    |---------+-----+-----+-----+------|
    | echo    |   7 |   7 | 862 |      |
    | discard |   9 |   9 | 863 |      |
    | daytime |  13 |  13 | 867 |      |
    | chargen |  19 |  19 | 864 |      |
    | time    |  37 |  37 | 868 |      |
*** 2.13 常见因特网应用的协议使用
    ping,traceroute ICMP
    - 路由协议
      OSPF IP
      RIP UDP
      BGP TCP
    - UDP网络应用
      - BOOTP
      - DHCP
      - NTP
      - TFTP
      - SNMP
    - TCP网络应用
      - SMTP
      - Telnet
      - SSH
      - FTP
      - HTTP
      - NNTP
      - LPR
    - UDP+TCP
      - DNS
      - NFS
      - SunRPC
      - DCE RPC
    - UDP+TCP+SCTP
      - IUA
      - M2UA/M3UA
      - H.248
      - H.323
      - SIP

* (二) 基本套接字编程
** 3. 套接字编成简介
*** 3.2 套接字地址结构
**** 3.2.1 IPv4套接字地址结构
     #+BEGIN_SRC c
     /**
       * Ubuntu18.04
       * /usr/include/netinet/in.h
       */
     /* Internet address.  */
     typedef uint32_t in_addr_t;
     struct in_addr{
         in_addr_t s_addr;
     };

     /* Structure describing an Internet socket address.  */
     struct sockaddr_in{
         __SOCKADDR_COMMON (sin_);
         in_port_t sin_port;         /* Port number.  */
         struct in_addr sin_addr;        /* Internet address.  */
         
         /* Pad to size of `struct sockaddr'.  */
         unsigned char sin_zero[sizeof (struct sockaddr) -
                                __SOCKADDR_COMMON_SIZE -
                                sizeof (in_port_t) -
                                sizeof (struct in_addr)];
     };
     /* unpv13 */
     struct sockaddr_in{
         uint8_t sin_len; /* length of struct */
         sa_family_t sin_family; /* AF_INET */
         in_port_t sin_port; /* network byte ordered */
         struct in_addr sin_addr; /* 32bit IPv4 address */
         char sin_zero[8]; /* unused */
     };
     #+END_SRC
**** 3.2.2 通用套接字地址结构
     #+BEGIN_SRC c
     // <sys/socket.h>
     struct sockaddr{
         uint8_t sa_len;
         sa_family_t sa_family;
         char sa_data[14];
     };

     int bind(int, struct sockaddr *, socklen_t);
     #+END_SRC
**** 3.2.3 IPv6地址结构
     #+BEGIN_SRC c
     struct in6_addr{
         uint8_t s6_addr[16];
     };
     #define SIN6_LEN /* required for compile-time tests */
     struct sockaddr_in6{
         uint8_t sin6_len;
         sa_fimily_t sin6_family; /* AF_INET6 */
         in_prot_t sin6_port;
         uint32_t sin6_flowinfo; /* 12bit(rev)20bit(flow label)*/
         struct in6_addr sin6_addr; /* 64字节对齐 */
         uint32_t sin6_scope_id; /* link-local address ... */
     };
     #+END_SRC
**** 3.2.4 新的通用套接字
     #+BEGIN_SRC c
     struct sockaddr_storage{
         uint8_t ss_len;
         sa_family_t ss_family;
         /*
          ,* a) alignment sufficient to fulfill the alignment
          ,* b) enough storage to hold and type of socket address
          ,*/
     }
     #+END_SRC
**** 3.2.5 套接字地址结构比较
     #+BEGIN_SRC c
     /*
      ,* IPv4, IPv6, Unix, Link, storage
      ,* IPv4, IPv6固定长度
      ,* Unix 可变长度
      */
     #+END_SRC
*** 3.3 值结果参数
    - 进程到内核
      connect(sockfd, (SA*) &serv, sizeof(serv));
    - 内核到进程
      - accept
      - recvfrom
      - getsockname
      - getpeername
*** 3.4 字节排序
    #+BEGIN_SRC c
    #include "unp.h"

    int main(int argc, char** argv){
        union{
            short s;
            char c[sizeof(short)];
        }un;
        un.s = 0x0102;

        printf("%s: ", CPU_VENDOR_OS);
        if(sizeof(short) == 2){
            if(un.c[0] == 1 && un.c[1] == 2){
                printf("big-endian\n");
            }else if(un.c[0] == 2 && un.c[1] == 1){
                printf("little-endian\n");
            }else{
                printf("unknown\n");
            }
        }else{
            printf("sizeof(short) = %d\n", sizeof(short));
        }
        exit(0);
    }
    #+END_SRC

    #+BEGIN_SRC c
    #inlude <netinet/in.h>

    uint16_t htons(uint16_t);
    uint32_t htonl(uint32_t);
    uint16_t ntohs(uint16_t);
    uint32_t ntohl(uint32_t);
    #+END_SRC
*** 3.5 字节操纵函数
    #+BEGIN_SRC c
    #include <string.h>
    void bzero(void *dest, sizeof nbytes);
    void bcopy(const void *src, void *dest, size_t nbytes);
    int bcmp(const void *p1, const void *p2, size_t nbytes);

    void *memset(void *dest, int c, size_t len);
    void *memset(void *dest, const void *src, size_t nbytes);
    int memcmp(const void *ptr, const void *ptr2, size_t bbytes);
    #+END_SRC
*** 3.6 inet_aton, inet_addr, inet_ntoa
    #+BEGIN_SRC c
    #include <arpa/inet.h>

    /**
     ,* @brief ascii to net
     ,* @param strptr [in] a.b.c.d
     ,* @param addrptr [out] inet addr
     ,* @return int
     ,* @retval 1 ok
     ,* @retval 0 error
     ,* @depracted by inet_pton()
     ,*/
    int inet_aton(const const char *strptr, struct in_addr *addrptr);

    /**
     ,* @brief ascii to inet_addr_t
     ,* @param strptr [in] a.b.c.d
     ,* @return inet_addr_t
     ,* @retval IPv4 32bit, network byte order
     ,* @retval INADDR_NONE (-1), when input is invalid
     ,* @deprecated by inet_aton()
     ,*/
    in_addt_t inet_addr(const char *strptr);

    /**
     ,* @brief 23bit to ascii
     ,* @return ascii net addr
     ,* @remark not thread safe, return buffer is lobal static
     ,* @deprecated by inet_ntop()
     ,*/
    char *inet_ntoa(struct in_addr inaddr);

    /**
     ,* @brief presentation to numeric(表达式转数值)
     ,* @param [in] af addr family, AF_INET|AF_INET6
     ,* @param [in] src string address
     ,* @param [out] dst is written in network byte order
     ,* @retval 1 ok
     ,* @retval 0 invalid presentation
     ,* @retval -1 error; see errno may EAFNOSUPPORT
     ,*
     ,*/
    int inet_pton(int af, const char *src, void *dist);
    /**
     ,* @brief numberic to presentation(数值转表达式)
     ,* @param [in] family AF_INET|AF_INET6
     ,* @param [in] addrptr numberic address
     ,* @param [out] strptr presentation buffer
     ,* @param [in] len size of strptr
     ,* @retval NULL len too small, errno=ENOSPC
     ,* @retval strptr OK
     ,*/
    const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);

    #include <netinet/in.h>
    #define INET_ADDRSTRLEN 16 /* for IPv4 dotted-decimal */
    #define INET6_ADDRSTRLEN 46 /* for IPv6 hex string */
    #+END_SRC
*** 3.7 inet_pton, inet_ntop
*** 3.8 sock_ntop
    #+BEGIN_SRC c
    #include "unp"
    char *sock_ntop(const struct sockaddr *sockaddr, socklen_t addrlen);
    int sock_pton();
    int sock_bind_wild(int fd, int family);
    int sock_cmp_addr();
    #+END_SRC
*** 3.9 readn, writen, readline
    #+BEGIN_SRC c
    #include "unp.h"
    /**
     ,* @remark MSG_WAITALL 标记可随recv函数一起使用来取代独立的readn
     ,*/
    ssize_t readn(int fd, void *buf, size_t nbytes);
    ssize_t writen(int fd, const void *buf, size_t nbytes);
    /**
     ,* @remark 可改用stdio，但不建议用
     ,*/
    ssize_t readline(int fd, void *buf, size_t maxlen);
    // >0 nbytes
    // -1 error
    #+END_SRC
** 4. 基本TCP套接字编成
*** 4.1 概述
*** 4.2 socket
    #+BEGIN_SRC c
    #include <sys/socket.h>
    /**
     ,* @brief creates an endpoint for cummunication and returns a file descriptor
     ,* @param [in] familly Specifies a communication domain;[AF_INET|INET6|UNIX|...]
     ,* @param [in] type Specifies the communication semantics.[SOCK_STREAM|DGRAM|RAW|RDM...]
     ,*              [SOCK_NOBLOCK|SOCK_CLOEXEC]
     ,*             SOCK_PACKET seam as BPF/DLPI
     ,* @param [in] protocol Specifies a particular protocol to be used with the socket; 0
     ,*
     ,*/
    int socket(int family, int type, int protocol);
    #+END_SRC
    - AF_XXX == PF_XXX
*** 4.3 connect()
    #+BEGIN_SRC c
    #include <sys/socket.h>

    /**
     ,* @brief connects <sockfd> to <servaddr>
     ,* @param [in] sockfd Socket file descriptor
     ,* @param [in] servaddr Server address
     ,* @param [in] addrlen Server address length
     ,* @return
     ,* @par If the <sockfd> is of type SOCK_DGRAM
     ,*      then <servaddr> is the address to which datagrams are sent by default,
     ,*      and the only address from which datagrams are received.
     ,*      use connect() multiple times to change their association, for connectionless;
     ,* @par If the <sockfd> is of type SOCK_STREAM or SOCK_SEQPACKET
     ,*      this call atemps to make a connection to the socket that is bound to <servaddr>
     ,*      call only once for connection-based protocol.
     ,* @par Errors
     ,*      -# ETIMEOUT: TCP客户端未收到SYN分节，和能目的主机不存在；
     ,*      -# ECONNREFUSED: TCP客户端收到RST响应，表明主机存在但对应服务端未启动；
     ,*      -# EHOSTUNREACH: SYN在中间某路由器上引发一个"destination unreachable"，无法路由；
     ,*      -# RST三条件
     ,*         * SYN到达目标端，但目标端未启动对应服务
     ,*         * TCP想取消一个已有连接
     ,*         * TCP接受到一个根本不存在的连接上的分节
     ,* @warning 如果套接字连接失败，则套接字不可再用且必须关闭
     ,*/
    int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
    #+END_SRC
*** bind()
    #+BEGIN_SRC c
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>

    /**
     ,* @brief bind <socketfd> to <addr>
     ,* @par Deacription
     ,*      When a socket is created, it exists in a namespace but has no address
     ,*      to it. <strong>bind()</strong> assigns the address <addr> to the socket
     ,*      refered to by the <sockfd>
     ,* @remark
     ,*  -# 绑定套接字到制定地址；
     ,*  -# 用getsockname来返回协议地址
     ,*  -# EADDRINUSE 解决: SO_REUSEADDR/SO_REUSEPORT
     ,*/
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    #+END_SRC
*** listen()
    #+BEGIN_SRC c
    #include <sys/socket.h>
    /**
     ,* @brief Marks the <sockfd> as a passive socket that will be used to accept() connections
     ,* @param [in] backlog defines the maxnum length to which the queue of pending connections
     ,*             if queue is full, the client may receive <strong>ECONNREFUSED</storng>
     ,* @retval 0 OK
     ,* @retval -1 errno
     ,*
     ,* @remark handleshake and calls
     ,*   client                 server
     ,*    | connect()            | listen()
     ,*    | -------(SYNj)------> | 在未完成队列建立条目
     ,*    | <-----(SYNk,ACKj+1)- | RTT
     ,*    | connect()return      |
     ,*    | ------(ACKk+1)-----> | 从未完成队列转移到已完成队列
     ,*    |                      | accept(); 获取连接套接字
     ,* @remark
     ,*  -# 如果backlog大于内核最大支持值，则内核会截断为自身支持的最大值
     ,*  -# 如果SYN分节到达，而队列满了，则TCP丢弃该分节来等待client重发SYN
     ,*  -# 未accept()前到达的数据缓存在接收缓冲区，最大未缓冲区大小；
     ,*/
    int listen(int sockfd, int backlog);
    #+END_SRC
*** accept()
    #+BEGIN_SRC c
    #include <sys/socket.h>

    /**
     ,* @brief It extracts the first connection request on the queue of pending connections
     ,*/
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    #+END_SRC
*** 4.7 fork() and exec()
    #+BEGIN_SRC c
    #include <unistd.h>

    /**
     ,* @brief Creates a new process by duplicating the calling process.
     ,* @retval 0  in sub process
     ,* @retval >0 in parent process
     ,* @retval -1 see errno
     ,*/
    pid_t fork(void);

    /**
     ,* @remark
     ,*  -# ${PATH}/filename --> pathname
     ,*  -# execlp() --> execvp()
     ,*  -# execvp() --> execv()
     ,*/
    int execlp(const char *filename, const char *arg0, .../* (char*)0 */);
    int execvp(const char *filename, char *const argv[]);
    /**
     ,* @remark
     ,*  -# execl() --> execv()
     ,*  -# execv() --> execve()
     ,*/
    int execl(const char *pathname, const char *arg0, .../* (char*)0 */);
    int execv(const char *pathname, char *const argv[]);

    /**
     ,* @remark
     ,*  -# execle() --> execve()
     ,*/
    int execle(const char *pathname, const char *arg0, .../* (char*)0, char *const envp[]*/);
    // the final exec systemcall
    int execve(const char *pathname, char *const argv[], const *const envp[]);
    #+END_SRC
*** 4.8 并发服务器
    #+BEGIN_SRC c
    /*
     ,* iterative server, server one by one
     ,* concurrent server, server parallel
     ,*/
    /* concurrent server demo
     ,*/
    pid_t pid;
    int listenfd, connfd;

    listenfd = socket(...);
    bind(listenfd, ...)
    listen(listenfd, 5);

    for(;;){
        connfd = accept(listenfd, ...);
        if((pid = Fork()) == 0){
            close(listenfd); /* child closes listening socket */
            doit(connfd); /* process the requires */
            close(connfd); /* done with this client */
            exit(0); /* child terminates */
        }
        close(connfd); /* 如果不调用，将耗尽所有套接字 */
    }
    #+END_SRC
*** 4.9 close()
    #+BEGIN_SRC c
    #include <unistd.h>
    /**
     ,* @remark
     ,*  -# 描述符引用计数
     ,*     shutdown() vs close()
     ,*/
    int close(int fd);
    #+END_SRC
*** 4.10 getsockname()/getpeername()
    #+BEGIN_SRC c
    #include <sys/socket.h>

    /**
     ,* @brief Returns the current address to which the socket is bound
     ,* @retval 0 ok
     ,* @retval -1 errno
     ,* @par 存在理由
     ,*  - 在没有bind()的client, connect() ok, getsockname() returns local ip/port
     ,*  - 以端口号0调用bind， getsockname() return bind port;
     ,*  - getsockname() return AF_xxx
     ,*  - bind(0:0) getsockname() return local ip/port
     ,*  - accept() -> exec() getpeername()
     ,*/
    int getsockname(int sockfd, SA* localaddr, socklen_t *addrlen);
    int getpeername(int sockfd, SA* peeraddr, socklen_t *addrlen);

    #include "unp.h"
    int sockfd_to_family(int sockfd){
        struct sockaddr_storage ss;
        socklen_t len;

        len = sizeof(ss);
        if(getsockname(sockfd, (SA*)&ss, &len) < 0){
            return -1;
        }
        return ss.ss_family;
    }
    #+END_SRC
** 5 TCP client/server sample
*** 5.1 概述
*** 5.2 echo server main()
    #+BEGIN_SRC c
    #include "unp.h"

    int main(int argc, char **argv){
        int listenfd, connfd;
        pid_t childpid;
        socklen_t chlilen;
        struct sickaddr_in cliaddr, servaddr;

        listenfd = Socket(AF_INET, SOCK_STREAM, 0);

        bzero(&serveraddr, sizeof(servaddr));
        servaddr.sin_family = AF_INET;
        servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
        servaddr.sin_port = htons(SERV_PORT);

        Bind(listenfd, (SA*)&servaddr, sizeof(servaddr));
        Listen(listenfd, LISTENQ);
        for(;;){
            clilen = sizeof(cliaddr);
            connfd = Accept(listenfd, (SA*)&cliaddr, &clilen);
            if( (childpid = Fork()) == 0){
                Close(listenfd);
                str_echo(connfd);
                exit(0);
            }
            Close(connfd);
        }
    }

    void str_echo(int sockfd){
        ssize_t n;
        char buf[MAXLINE];

    again:
        while((n = read(sockfd, buf, MAXLINE)) > 0){
            Writen(sockfd, buf, n);
        }
        if(n < 0 && errno == EINTR){
            goto again;
        }else if( n < 0){
            err_sys("str_echo: read error");
        }
    }
    #+END_SRC
*** TCP client main()
    #+BEGIN_SRC c
    #include "unp.h"

    int main(int argc, char **argv){
        int sockfd;
        struct sockaddr_in servaddr;

        if(argc != 2){
            err_quit("usage: tcpcli <IPaddress>");
        }

        sockfd = Socket(AF_INET, SOCK_STREAM, 0);
        bzero(&servaddr, sizeof(servaddr));
        servaddr.sin_family = AF_INET;
        servaddr.sin_port = htons(SERV_PORT);
        Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);

        Connect(sockfd, (SA *)&servaddr, sizeof(servaddr));
        str_cli(stdin, sockfd);
        exit(0);
    }

    void str_cli(FILE *pf, int sockfd){
        char readline[MAXLINE], recvline[MAXLINE];
        while(Fgets(sendline, MAXLINE, pf) != NULL){
            Writen(sockfd, sendline, strlen(sendline));
            if(Readline(sockfd, recvline, MAXLINE) == 0){
                err_quit("str_cli: server terminated prematurely");
            }
            Fputs(recvline, stdout);
        }
    }
    #+END_SRC
*** 5.7 正常终止
    #+BEGIN_SRC sh
    ps -t pts/1 -o pid,ppid,tty,stat,args,wchan
    :<<!
      PID  PPID TT       STAT COMMAND                     WCHAN
     2105 27815 pts/1    S    ./tcpserv01                 inet_csk_accept
     2202 27815 pts/1    S+   ./tcpcli01 127.0.0.1        wait_woken
     2203  2105 pts/1    S    ./tcpserv01                 wait_woken
    27815 23133 pts/1    Ss   /bin/bash --noediting -i    wait
    !
    ps -t pts/1 -o pid,ppid,tty,stat,args,wchan
    :<<!
      PID  PPID TT       STAT COMMAND                     WCHAN
     2105 27815 pts/1    S    ./tcpserv01                 inet_csk_accept
     2203  2105 pts/1    Z    [tcpserv01] <defunct>       -
    27815 23133 pts/1    Ss+  /bin/bash --noediting -i    wait_woken
    !

    ps -t pts/1 -o pid,ppid,tty,stat,args,wchan
    :<<!
      PID  PPID TT       STAT COMMAND                     WCHAN
    27815 23133 pts/1    Ss+  /bin/bash --noediting -i    wait_woken
    !
    #+END_SRC
*** 5.8 POSIX信号处理
    #+BEGIN_SRC c
    #include "unp.h"

    Sigfunc *signal(int signo, Sigfunc *func){
        struct sigaction act, oact;
        act.sa_handler = func;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        if(signo == SIGALRM){
    #ifdef SA_INTERRUPT
            act.sa_flags |= SA_INTERRUPT; /* SunOS 4.x */
        }else{
    #ifdef SA_RESTART
            act.sa_flags |= SA_RESTART; /* SVR4, 44BSD */
    #endif
        }
        if(sigaction(signo, &act, &oact) < 0){
            return SIG_ERR;
        }
        return(oact.sa_handler);
    }

    void sig_child(int signo){
        pid_t pid;
        int stat;
        pid = wait(&stat);
        printf("child %d terminated\n", pid);
        return;
    }
    #+END_SRC
*** 5.10 wait() and waitpid()
    #+BEGIN_SRC c
    #include <sys/wait.h>

    /**
     ,* @remark
     ,*  -# 缺陷，由于信号不排队，不能处理多个子进程同时结束
     ,*/
    pid_t wait(int *statloc);
    /**
     ,* @param [in] pid -1 wait first child terminated
     ,*                 <pid> wait <pid> child terminated
     ,* @param [out] *statloc
     ,* @param [in] options [WNOHANG]
     ,*/
    pid_t waitpid(pid_t pid, int *statloc, int options);

    #include "unp.h"
    void sig_chld(int signo){
        pid_t pid;
        int stat;
        // 解决wait()缺陷
        while((pid = waitpid(-1, &stat, WNOHANG)) > 0){
            printf("child %d terminated\n", pid); // 处理多个僵尸进程
        }
        return;
    }
    #+END_SRC
*** 5.11 accept返回前连接终止
    #+BEGIN_SRC c
    // 受到非严重错误ECONNNABORTED/EPROTO 时再次执行accept
    #+END_SRC
*** 5.12 服务器进程终止
    - stdin/fd 不能同时监听事件，从而引入select()/poll()机制
*** 5.13 SIGPIPE信号
    - 处理服务端发送RST
    - 当进程向某个已经接收到RST的套接字执行写操作是，内核产生SIGPIPE。
      *手动捕获设置未SIG_IGN，否则会默认终止进程*
*** 5.14 服务器主机崩溃
    client                                servers
     | connected                           |
     |         断开网线                     | 
     | writen  （超时重传）                | 无法接收
     | readline (阻塞)                     |
     |          (超时)                     |
     | ETIMEOUT/EHOSTUNREACH               |

     利用 SO_KEEPALIVE 套接字选项来处理该问题
*** 5.15 服务器主机崩溃后重启
    client                                servers
    | connected                           |
    |                                     | 断开网线
    | write                               | 重启主机
    |                                     | 连接网线
    | RST                                 |
    | ECONNRESET                          |

    利用 SO_KEEPALIVE
*** 5.16 服务器主机关机
    系统关机是 init 向所有进程发送 SIGTERM 过5~20秒(留时间清理数据) 发送 SIGKILL;

* (三) 高级套接字编程